# 第一章 Java概述

## 1.1 Java历史

Java诞生于SUN（Stanford University Network），09年被Oracle（甲骨文）收购。

Java之父：詹姆斯.高斯林

1996初发布JDK1.0.

目前的最新版本：Java13

学习和开发的版本：1.8



## 1.2 安装与环境搭建有关

1、相关名称

JDK：Java Developer's kit，Java开发工具包

JRE：Java Runtime Environment，Java运行环境

JVM：Java Virtual Machine，Java虚拟机

关系：

JDK = JRE + 开发工具（例如：javac.exe，java.exe，javadoc.exe, jar.....)

JRE = JVM + 核心类库（例如：String，System。。。）

JVM：Java跨平台的根本原因



Java开发人员需要安装JDK。



2、环境变量

（1）path

为什么要配置path?

希望在任意目录下都可以找到对应的工具。例如：javac.exe等

（2）JAVA_HOME后面再讲



## 1.3 Java第一个应用程序

1、Java程序的开发步骤

（1）编写

结果：.java的源文件

源代码的结构：

```
类{
	方法{
		语句;
	}
}
```

（2）编译

结果：.class的字节码文件

工具：javac.exe

格式：

```cmd
javac 源文件名.java
```

（3）运行

工具：java.exe

格式：

```cmd
java 类名
或
java 字节码文件名
```

> java命令后面不要写   java  字节码文件名.class（错误的）



2、Java程序的入口：main

```java
public static void main(String[] args){

}
```



# 第二章 Java基础语法

## 2.1 Java的注释

1、单行注释

```java
//注释的内容
```

2、多行注释

```java
/*
注释内容
*/
```

注意：多行注释不能嵌套

3、文档注释：后面再讲

```java
/**
 文档注释内容
*/
```



## 2.2 关键字

关键字：50个

​	今天接触的关键字：public,static,void,byte,short,int,long,float,double,char,boolean

其中保留字：const和goto

特殊值：3个，true,false,null

![1555209180504](imgs/关键字表.png)

## 2.3 标识符

标识符：凡是代码中自己命名的部分，例如：类名，变量名等

标识符的命名规则：

（1）由26个英文字母大小写，数字0-9，下划线_，美元符号$

（2）数字不能开头

（3）不能直接使用关键字和保留字、特殊值

（4）严格区分大小写

（5）不能包含空格

标识符的命名规范：

（1）见名知意

（2）类名、接口名：每一个单词的首字母大写，XxxYyyZzz

（3）变量名、方法名：从第二个单词开始首字母大写，xxxYyyZzz

（4）包名：所有单词都小写，每个单词使用.分割，xxx.yyy.zzz

（5）常量名：所有字母都大写，每个单词之间使用_分割，XXX_YYY_ZZZ



## 2.4 变量

变量：用来存储数据的，代表内存的一块区域。

变量的三要素：

（1）数据类型

（2）变量名

（3）变量值

如何声明/定义变量？

```
数据类型 变量名;
```

变量的赋值：

```
变量名 = 变量值;
```

变量使用的四个要求：

（1）先声明/定义后使用

（2）不能重复声明

（3）在使用之前必须先初始化

（4）变量有作用域

## 2.5 数据类型

Java数据类型分为两大类：

1、基本数据类型

（1）整型

byte、short、int、long

特殊：在long类型的数字后面加L或l

（2）浮点型

float、double

特殊：在float类型的数字后面加F或f

（3）字符型

char

特殊：需要使用单引号

（4）布尔型

boolean

特殊：只有两个值true和false

2、引用数据类型

类：例如：String

接口

枚举

数组

...

## 2.6 两种输出

（1）输出并换行

```java
System.out.println();
System.out.println(xx);
```

（2）输出不换行

```java
System.out.print(xx);
```

## 2.7 进制

1、常见的进制

* 十进制：生活中使用的，因此程序显示的结果也是十进制
  * 数字组成：0-9
  * 进位规则：逢十进一
  * 程序中表示方式：正常表示
* 二进制：计算机底层存储和处理数据使用的
  * 数字组成：0-1
  * 进位规则：逢二进一
  * 程序中表示方式：0B或0b开头
* 八进制：方便在程序中表示二进制用的
  * 数字组成：0-7
  * 进位规则：逢八进一
  * 程序中表示方式：0开头
* 十六进制：方便在程序中表示二进制用的
  * 数字组成：0-9，a-f（大小写字母都可以）
  * 进位规则：逢十六进一
  * 程序中表示方式：0X或0x开头

2、计算机存储单位

最小单位：bit比特

最基本单位：byte字节

3、底层存储和计算使用的是补码

正数：原码、反码、补码三码合一

负数：原码、反码、补码不同

最高位表示正负号，0表示正数，1表示负数

负数的原码：最高位是1，剩下的是它绝对值的二进制值

负数的反码：最高位不变，其余取反（1变0，0变1）

负数的补码：反码+1

4、进制转换规则

* 十进制->二进制：
  * 整数部分：除2倒取余
  * 小数部分：乘2取整
* 二进制->十进制
  * 从最右开始，依次乘以2的0次，1次...，最后累加和
* 二进制->八进制
  * 三位一组合
* 二进制->十六进制
  * 四位一组合

## 2.8 数据类型

### 2.8.1 数据类型的表示范围

* byte
  * 占的内存：1个字节
  * 范围：-128~127
* short
  * 占的内存：2个字节
  * 范围：-32768~32767
* int
  * 占的内存：4个字节
  * 范围：-2的31次方 ~ 2的31次-1
* long
  * 占的内存：8个字节
  * 范围：-2的63次方 ~ 2的63次-1
  * 某个常量数字要表示为long类型，在数字后面加L
* float
  * 占的内存：4个字节
  * 精度范围：科学记数法小数点后7~8位
  * 某个常量数字要表示为float类型，在数字后面加F或f
* double
  * 占的内存：8个字节
  * 精度范围：科学记数法小数点后15~16位
* char
  * 占的内存：2个字节
  * 字符编码范围：0~65535
  * 使用的是Unicode字符集
  * 程序中有三种字符表示方式：
    * 单引号中加单个字符：'a','尚'
    * 单引号中加转义字符：\n,\t,\r,\b,\\\,\\',\\"
    * 单引号中加编码值：\u5c1a'
* boolean
  * 两个值：true和false
  * 实际上底层是使用1表示true，0表示false

### 2.8.2 基本数据类型的转换

1、自动类型转换

（1）当我们把存储范围或精度范围小的赋值给存储范围或精度范围大的变量时

（2）当我们把存储范围或精度范围小的与存储范围或精度范围大的类型一起运算时

byte->short->int->long->float->double

​            char->

（3）当两个byte,short,char它们的运算会升级为int

（4）当与String进行拼接“+”运算，结果都是String

2、强制类型转换

格式：(需要强制为的类型)值/变量

（1）当我们把存储范围或精度范围大的赋值给存储范围或精度范围小的变量时

double->float->long->int->short->byte

​											->char

这种强制类型转换有风险，可能溢出或损失精度

（2）故意提升某个变量/值的类型，也可以使用强制类型转换



无论是自动类型转换还是强制类型转换：boolean不参与



## 2.9 运算符

### 2.9.1 算术运算符

* 加：+
* 减：-
* 乘：*
* 除：/
  * 整数与整数相除，结果还是整数，即只保留整数部分
* 模/取余：%
  * 结果的正负号只看被除数
* 正号：+
* 负号：-
* 自增：++
  * 单独运算：++在前在后没有影响
  * 复合运算：
    * ++在前，先自增再取值到操作数栈
    * ++在后，先取值放到操作数栈然后变量自己自增
* 自减：--
  * 类同于自增

### 2.9.2 赋值运算符

* 基本赋值运算符：=
* 扩展赋值运算符：+=，-=，*=，/=,%=，>>=，<<=，&=....
  * 会用=左边的变量的值，与=右边的表达式一起做运算，并且如果最后计算结果的类型比左边的变量的类型大了，会隐式的发生强制类型转换

注意：无论是基本赋值运算符还是扩展赋值运算符都是最后算，并且是把右边的计算的结果最后赋值给左边的变量，即左边一定是一个变量

```java
byte b1 = 1;
byte b2 = 2;
byte b3 = b1 + b2;//编译错

b1 +=  b2;//编译通过
```

### 2.9.3 关系运算符/比较运算符

* 大于：>
* 小于：<
* 大于等于：>=
* 小于等于：<=
* 等于：==
* 不等于：!=

注意：所有比较运算符的结果都是true/false，所以比较运算符通常用作条件判断



### 2.9.4 逻辑运算符

* 逻辑与：&
  * true & true，结果是true
  * true & false，结果是false
  * false & true，结果是false
  * false & false，结果是false
  * 只有两边都是true，结果才为true
* 逻辑或：|
  * true | true，结果是true
  * true | false，结果是true
  * false | true，结果是true
  * false | false，结果是false
  * 只要两边有一个为true，结果就为true
* 逻辑非：!
  * ！true为false
  * ! false为true
* 逻辑异或：^
  * true ^ true，结果是false
  * true ^ false，结果是true
  * false ^ true，结果是true
  * false ^ false，结果是false
  * 两边相同为false，不同为true
* 短路与：&&
  * true && true，结果是true
  * true && false，结果是false
  * false && true，结果是false
  * false && false，结果是false
  * 只有两边都是true，结果才为true，但是当左边为false时，右边不看
* 短路或：||
  * true || true，结果是true
  * true || false，结果是true
  * false || true，结果是true
  * false || false，结果是false
  * 只要两边有一个为true，结果就为true，但是当左边为true时，右边不看



注意：逻辑运算符的操作数必须是boolean类型

### 2.9.5 条件运算符/三元运算符

格式：条件表达式 ? 结果表达式1 : 结果表达式2

当条件表达式为true时，就取结果表达式1的值，否则取结果表达式2的值



### 2.9.6 位运算符

* 左移：<<
  * 快速算的口诀：乘以2的n次方
* 右移：>>
  * 快速算的口诀：除以2的n次方
* 无符号右移：>>>
  * 正数：和右移一样
  * 负数：变为正数
* 按位与：&
  * 1 & 1结果是1
  * 1 & 0结果是0
  * 0 & 1结果为0
  * 0 & 0结果为0
* 按位或：|
  * 1 | 1结果是1
  * 1 | 0结果是1
  * 0 | 1结果为1
  * 0 | 0结果为0
* 按位异或：^
  * 1 ^ 1结果是0
  * 1 ^ 0结果是1
  * 0 ^ 1结果为1
  * 0 ^ 0结果为0
* 按位取反：~
  * ~1为0
  * ~0为1



注意：

（1）当左移、右移、无符号右移要移动的位数超过数据类型的总位数，那么会出现循环，当你移的位数没有超过数据类型的总位数时，不会出现循环。这里要注意，byte,short,char在移位时，按照int类型处理。

（2）在补码的基础上计算

### 2.9.7 运算符优先级

大体上：()等 > 算术运算符 > 位运算符 > 比较运算符 > 逻辑运算符 > 条件运算符 > 赋值运算符

自己写的原则：尽量不要太复杂，保证可读性

# 第三章 流程控制语句结构

流程控制语句结构分为：

* 顺序结构
* 分支结构
* 循环结构

## 3.1 顺序结构

特点：依次从上往下顺序执行

### 3.1.1 输出语句

1、输出后换行

```java
System.out.println();
```

2、输出后不换行

```java
System.out.print();	
```

### 3.1.2 输入语句

步骤：

1、准备键盘输入的变量

2、用输出语句提示用户输入xx信息

3、接收键盘输入结果

```java
//1、准备键盘输入的变量
java.util.Scanner input = new java.util.Scanner(System.in);

//2、提示输入
System.out.print("姓名：");
String name = input.next();

System.out.print("年龄：");
int age = input.nextInt();

System.out.print("体重：");
double weight = input.nextDouble();

System.out.print("性别：");
char gender = input.next().charAt(0);

System.out.print("是否已婚(true/false)：");
boolean marry = input.nextBoolean();
```

next()与nextLine()

```java
next()：遇到空白符就输入结束
nextLine()：能够接收一行，遇到换行符结束
```

## 3.2 分支结构

### 3.2.1 条件判断

#### 1、单分支条件判断

语法结构：

```java
if(条件表达式){
	语句块;
}
```

执行特点：

当条件表达式成立时，执行语句块，否则就不执行。

要求：

（1）if(条件表达式)中“条件表达式”必须是boolean类型

（2）{语句块;}中当语句块只有一个语句时，可以省略{}，不建议省略

> 一个语句可以是简单的输出语句，赋值语句，也可以是复合语句，例如一个完整的单分支、双分支，多分支，选择分支，或一个完整的循环结构...

#### 2、双分支条件判断

语法结构：

```java
if(条件表达式){
	语句块1;
}else{
	语句块2;
}
```

执行特点：

当条件表达式成立时，执行语句块1，否则执行语句块2。

要求：

（1）if(条件表达式)中“条件表达式”必须是boolean类型

（2）{语句块;}中当语句块只有一个语句时，可以省略{}，不建议省略

#### 3、多分支条件判断

```java
if(条件表达式1){
	语句块1;
}else if(条件表达式2){
	语句块2;
}else if(条件表达式2){
	语句块2;
}
。。。
【
else{
	语句块n+1;
}
】
```

执行特点：

（1）先判断条件表达式1，

A：如果条件表达式1成立，执行语句块1，结束整个多分支结构

B：如果条件表达式1不成立，不执行语句块1，转到（2）

（2）判断条件表达式2，

A：如果条件表达式2成立，执行语句块2，结束整个多分支结构

B：如果条件表达式2不成立，不执行语句块2，转到（3）

（3）。。。。

（n+1）当以上所有条件表达式都不成立，如果存在最后单独的else，执行最后的else中的语句块n+1;

要求：

（1）if(条件表达式)中“条件表达式”必须是boolean类型

（2）{语句块;}中当语句块只有一个语句时，可以省略{}，不建议省略

（3）当多个条件的范围没有重叠部分，顺序可以随意，但是条件范围如果有重叠部分，顺序有要求，范围小的在上面，大的在下面

#### 4、嵌套

在任意一个if的{}或者else的{}中都可以再嵌套任意一种分支结构。

执行原则：

如果嵌套在if的{}中，当外面的if条件满足时，才会看里面的分支结构；

如果嵌套在else的{}中，当外面的if条件不满足时，才会进入else里面的分支结构；

### 3.2.2 选择结构

语法格式：

```java
switch(表达式){
case 常量值1:
	语句块1;
	【break;】
case 常量值2：
	语句块2;
	【break;】
....
default:
	语句块n+1;
	【break;】
}
```

执行的特点：

（1）入口

A：case入口：当switch(表达式)中表达式的值与某个case后面的常量值匹配，就从这个case进入

B：default入口：当switch(表达式)中表达式的值与所有case后面的常量值都不匹配，从default进入

（2）出口

A：自然出口：从switch的结束}结束

B：中断出口：遇到break，return...

（3）一旦从入口进入，在没有遇到出口之前，一直往下执行，甚至会贯穿case

要求：

（1）switch(表达式)的类型有要求：4种基本数据类型（byte,short,char,int），两种引用数据类型（JDK1.5之后枚举，JDK1.7String类型）

（2）case后面必须是常量值，不能是变量

（3）case后面的常量值不能重复

### 3.3.1 while循环

1、语法结构

```java
while(循环条件){
	循环体语句块;
}
```

执行过程：

（1）先判断循环条件

A：如果条件成立，执行循环体语句块，然后回到（1）

B：如果条件不成立，直接结束while

要求：

（1）while(循环条件)的条件必须是boolean

（2）如果循环体语句块只有一个语句，{}可以省略，但是不建议省略



### 3.3.2 do...while循环

语法结构：

```java
do{
	循环体语句块;
}while(循环条件);
```

执行过程：

（1）先执行一次循环体语句块

（2）判断循环条件

A：如果条件成立，再次执行循环体语句块，然后回到（2）

B：如果条件不成立，直接结束do..while

要求：

（1）while(循环条件)的条件必须是boolean

（2）如果循环体语句块只有一个语句，{}可以省略，但是不建议省略

（3）do...while结构的while()小括号后面的;不能省略

### 3.3.3 for循环

1、语法结构

```java
for(;;){
	循环体语句块;
}
```

执行特点：

（1）如果在循环体语句块中没有break,return等结束循环的语句的话，那么它就是死循环

```
for(初始化表达式; 循环条件; 迭代表达式){
	循环体语句块;
}
```

执行特点：

（1）先执行初始化表达式;

（2）判断循环条件

A：条件成立，执行循环体语句块，然后执行迭代表达式，再回到（2）

B：条件不成立，结束for



要求：

for(;;)两个分号不能多也不能少；

循环条件必须是boolean类型

如果循环体语句块只有一个语句，{}可以省略，但是不建议省略

### 3.3.4 嵌套

外循环循环一次，内循环循环一轮



### 3.3.5 跳转

1、break

用于（1）switch，表示结束当前switch（2）循环，表示结束当前循环

说明：如果break在嵌套循环的内循环中，只能结束内循环

2、continue

用于（1）循环，表示提前结束本次循环，跳过本次循环剩下的循环体语句块，提前进入迭代

# 第四章 数组

## 4.1 数组的概念

数组：用来存储和管理一组相同数据类型的数据。它是一种容器。

数组名：为了方便存储和管理一组相同数据类型的数据，使用一个统一的名称来管理它们。

下标：为了区别一组数组中的每一个，使用编号/索引/下标来表示

元素：这一组数据中的每一个数据是一个元素，表示方式：数组名[下标]

数组的长度：数组的元素的总个数，表示方式：数组名.length

下标的范围：[0, 数组的长度-1]

数组名：记录这一组数据在“堆”内存中的首地址。

下标从0开始：距离首地址间隔0个单元格



## 4.2 一维数组

1、声明的格式

```java
元素的数据类型[] 数组名;//推荐

或
    
元素的数据类型  数组名[];
```

2、初始化方式

（1）静态初始化

```java
元素的数据类型[] 数组名 = {元素值1,元素值2。。。。};

//如果分开两行
元素的数据类型[] 数组名;
数组名 = new 元素的数据类型[]{元素值1,元素值2。。。。};
```

静态初始化的方式，在创建数组对象的同时就指定了数组的元素的值，而且数组的长度由列出来的元素的个数决定。

（2）动态初始化

```java
元素的数据类型[] 数组名 = new 元素的数据类型[长度];

//如果分开两行
元素的数据类型[] 数组名;
数组名 = new 元素的数据类型[长度];
```

动态初始化的方式，在我们创建完数组对象时，还没有为元素赋值的话，元素是默认值。

3、为元素赋值

```java
数组名[下标] = 值;
```

```java
arr[i] = 常量值; //常量值为元素赋值
arr[i] = (int)(Math.random()*100); //使用随机数为元素赋值
arr[i] = input.nextInt(); //从键盘输入为元素赋值
arr[i] = i*2 + 1; //使用表达式的结果为元素赋值
```

4、遍历

```java
for(int i=0; i<数组的长度; i++){
	//数组名[i]表示元素
}
```

5、数组元素的默认值

byte,short,int,long：默认值是0

float,double：默认值是0.0

char：默认值是编码值为0的字符，\u0000

boolean：默认值是false

引用数据类型：null



6、一维数组的内存分析

凡是数组，即new出来都在堆中。

数组的元素是连续存储的。



## 4.3 一维数组的基础算法

### 1、求和

```java
int[] arr = {3,2,5,1,4};

int sum = 0;
for(int i=0; i<arr.length; i++){
	sum += arr[i];
}
```

### 2、求均值

```java
int[] arr = {3,2,5,1,4};

double sum = 0;
for(int i=0; i<arr.length; i++){
	sum += arr[i];
}

double avg = sum / arr.length;
```

### 3、统计偶数/奇数个数

```java
int[] arr = {3,2,5,1,4};

int odd = 0;
int even = 0;
for(int i=0; i<arr.length; i++){
	if(arr[i] % 2==0 ){
		even++;
	}else{
		odd++;
	}
}
```

### 4、查找

顺序查找

```java
int[] arr = {3,2,5,1,4};

int findValue = ?;

int index = -1;
for(int i=0; i<arr.length; i++){
    if(arr[i] == findValue){
        index = i;
        break;
    }
}
if(index==-1){
    System.out.println("不存在");
}else{
    System.out.println(findValue + "的下标是" + index);
}
```

```java
String[] names = {"张三","李四","王五"};

String findValue = ?;

int index = -1;
for(int i=0; i<arr.length; i++){
    if(arr[i].equals(findValue)){
        index = i;
        break;
    }
}
if(index==-1){
    System.out.println("不存在");
}else{
    System.out.println(findValue + "的下标是" + index);
}
```

### 5、找最值

```java
int[] arr = {3,2,5,1,4};

int max = arr[0];//假设第一个最大
//和后面的元素一一比较
for(int i=1; i<arr.length; i++){
	if(arr[i] > max){
		max = arr[i];
	}
}
```

### 6、找最值下标

```java
int[] arr = {3,2,5,1,4};

int max = arr[0];//假设第一个最大
int index = 0;
//和后面的元素一一比较
for(int i=1; i<arr.length; i++){
	if(arr[i] > max){
		max = arr[i];
        index = i;
	}
}
```

```java
int[] arr = {3,2,5,1,4};

int index = 0;//假设第一个最大
//和后面的元素一一比较
for(int i=1; i<arr.length; i++){
	if(arr[i] > arr[index]){
        index = i;
	}
}

System.out.println("最大值是：" + arr[index]);
```

### 7、排序

冒泡排序：

结果：从小到大排序

（1）从左边开始把大的往右边移动

```java
int[] arr = {3,2,5,1,4};

for(int i=1; i<arr.length; i++){
    /*
    因为每一轮从最左边开始，int j=0;起始值
    i=1, j=0,1,2,3
    i=2, j=0,1,2
    i=3, j=0,1
    i=4, j=0
    j<arr.length-i
    */
    for(int j=0; j<arr.length-i ; j++){
        //前面的元素 > 后面的元素
        /*
        前后元素：arr[j]与[j+1]
        前后元素：arr[j-1]与arr[j]  因为我这里j=0开始，arr[j-1]当j=0的时候会越界
        */
        if(arr[j] > arr[j+1]){
            int temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        }
    }
}
```

（2）从右边开始把小的往左边移动

```java
int[] arr = {3,2,5,1,4};

for(int i=1; i<arr.length; i++){
	/*
	因为从右边开始把小的往左边移动，所以j的起始点  arr.length-1
	i=1, j=4,3,2,1
	i=2, j=4,3,2
	i=3, j=4,3
	i=4, j=4
	int j = arr.length-1； j>=i; j--
	*/
	for(int j=arr.length-1; j>=i; j--){
		//右边的元素 < 左边的元素 交换
		/*
        右边与左边元素：arr[j]与[j-1]
        右边与左边元素：arr[j+1]与arr[j] 因为j的起始点arr.length-1,[j+1]会导致越界
        */
        if(arr[j] < arr[j-1]){
        	int temp = arr[j];
        	arr[j] = arr[j-1];
        	arr[j-1] = temp;
        }
	}
}
```



## 4.4 二维数组

1、声明格式

```java
数组的元素类型[][] 数组名;//推荐写法

或
数组的元素类型 数组名[][];

或
数组的元素类型[] 数组名[];
```

```java
class Test04Review4{
	public static void main(String[] args){
		//标准声明二维数组的方式
		int[][] arr1 = new int[3][];
		
		//其他的方式
		int arr2[][] = new int[3][];
		
		int[] arr3[] = new int[3][];
		
		System.out.println(arr1);//[[I@15db9742
		System.out.println(arr2);//[[I@6d06d69c
		System.out.println(arr3);//[[I@7852e922
		
		//面试题
		int[] x, y[];
		//答案：x是一维数组，y是二维数组
        
        //x = new int[2][];//错误，因为x是一维数组
		//y = new int[3];//错误的，一维y是二维数组
	}
}
```

2、初始化

（1）静态初始化

```java
数组的元素类型[][] 数组名 = {{第一行的元素} ， {第二行的元素} 。。。};

//分开两行代码
数组的元素类型[][] 数组名;
数组名 = new 数组的元素类型[][]{{第一行的元素} ， {第二行的元素} 。。。};
```

（2）动态初始化：每一行的列数可能不同

```java
数组的元素类型[][] 数组名 = new 数组的元素类型[总行数][];

//单独指定每一行的列数
数组名[行下标] = new 元素的类型[列数];//每一行是一个一维数组
```

（3）动态初始化：每一行的列数相同

```java
数组的元素类型[][] 数组名 = new 数组的元素类型[总行数][列数];
```

3、遍历

二维数组的长度，二维数组的总行数：数组名.length

二维数组的某一行：数组名[行下标]

二维数组的某一行的列数，某一行的长度：数组名[行下标].length

行下标的范围：[0, 数组名.length-1]

二维数组的某个元素：数组名\[行下标\][列下标]

列下标的范围：[0, 数组名[行下标].length-1 ]

```java
for(int i=0; i<数组名.length; i++){
	for(int j=0; j<数组名[i].length; j++){
		//元素：数组名[i][j]
	}
}
```

4、二维数组的内存分析



## 4.5 在数组使用过程中经常遇到的两种异常

### 1、数组下标越界异常：ArrayIndexOutOfBoundsException

一维数组的下标范围：[0， 数组名.length-1]

二维数组的行下标范围：[0, 数组名.length-1]

二维数组的列下标范围：[0, 数组名[行下标].length -1]



### 2、空指针异常：NullPointerExeption

元素是引用数据类型：

例如：String[]，Student[]...

这种数组的元素的默认值是null，在给元素赋值之前，使用数组的元素进行.操作就会报空指针异常

```java
String[] names = new String[3];
System.out.println(names[0].charAt(0));//names[0]是null
```

使用二维数组时，如果没有为行指定列数，那么此时行是null

```java
int[][] arr = new int[3][];

System.out.println(arr[0].length);//arr[0]是null
System.out.println(arr[0][0]);//arr[0]是null
```

# 第五章 面向对象基础（上）

## 5.1 面向对象编程思想

面向对象的编程特点：

以类/对象为最基本单位



## 5.2 类与对象

### 5.2.1 类与对象的概念

类：一类具有相同特性的事物的“抽象”描述。

对象：是类的一个具体的实例，个体。

类是创建对象的模板，设计图。根据某个类创建（new）的对象都具有这个类中声明的特征。

例如：Student是类，张三这个学生是Student的一个具体的对象，实例。



### 5.2.2 如何声明类

语法格式

```java
【修饰符】 class 类名{
	//成员列表
}
```

### 5.2.3 如何创建对象

语法格式

```java
//(1)有名字的对象
类名  对象名/变量名 = new 类名();

//(2)匿名对象
例如：
System.out.println(new 类名());
new 类名().方法();
```

> 看到new，就说明在创建对象

## 5.3 类的成员之一：成员变量

### 5.3.1 如何声明成员变量

```java
【修饰符】 class 类名{
	【修饰符】 数据类型 成员变量名;
}
```

> 成员变量声明的位置：类中方法外



### 5.3.2 成员变量的分类

根据是不是有static修饰来分：

1、静态变量：有static修饰的成员变量，有的时候也称为类变量

2、实例变量：没有static修饰的成员变量



### 5.3.3 特点

#### 1、成员变量有默认值

byte,short,int,long：默认值是0

float,doube：默认值是0.0

char：默认值是\u0000

boolean：默认值是false

其他的引用数据类型：null



#### 2、静态变量的值是该类所有对象共享的；实例变量的值是每一个对象独立的



### 5.3.4 如何在类外面访问成员变量

#### 1、静态的类变量

（1）类名.静态变量：推荐

（2）对象.静态变量



#### 2、实例变量

只能使用 对象.实例变量



### 5.3.5 成员变量的内存分析

#### 1、静态的类变量：方法区

#### 2、非静态的实例变量：堆



## 5.4 类的成员之二：成员方法

### 5.4.1 方法的概念

方法代表一个独立的可复用的功能。

例如：Math.sqrt(x)每一次调用都可以获取某个数的平方根，而我们调用者不需要知道内部是如何实现的。

方法在一个类中，特别标准的Javabean等，方法又代表了事物的行为能力，行为特征。



### 5.4.2 成员方法分类

1、静态方法：又称为类方法

2、非静态方法：又称为实例方法



### 5.4.3 如何声明/定义成员方法

1、语法格式

```java
【修饰符】 class 类名{
	【修饰符】 返回值类型 方法名(形参列表){
		方法体
	}
}
```

> 一个完整的方法 = 方法头 + 方法体
>
> 方法头：【修饰符】 返回值类型 方法名(形参列表)，方法头又称为方法签名
>
> 我们调用者一般只需要关注“方法签名"，内部的方法体实现可以不清楚。
>
> 我们设计者/声明者，既需要设计“方法签名”，还得编写”方法体“的实现。

2、说明

（1）【修饰符】：目前只用了static

* ​	有static修饰的就是静态方法
* ​	没有static修饰的就是非静态实例方法

（2）返回值类型

* void：表示无返回结果
* 基本数据类型：8种
* 引用数据类型：类、数组、接口、枚举。。。

（3）方法名

* 见名知意：尽量能够代表方法的功能
* 从第二个单词开始首字母大写

（4）形参列表

* ()：无参
* (数据类型 形参名， 数据类型  形参名 。。。)：有参

形参的数据类型，可以是基本数据类型，也可以是引用数据类型。



### 5.4.4 如何调用

#### 1、是否静态的规则

1、静态类方法

（1）在其他类中

A：类名.方法     推荐

B：对象.方法

（2）在本类中

直接被使用就可以

2、非静态实例方法

（1）在其他类中

只能用  对象.方法

（2）在本类中

除了在静态方法中不能直接使用它，其他地方也是直接使用



#### 2、是否有参

调用时，是否需要传“实参”，看被调用的方法是否有“形参”，

要求实参的个数、类型、顺序要与形参列表一一对应。



#### 3、是否有返回值

* void：不能接收，也不能打印调用结果
* 基本数据类型/引用数据类型：可以接收，也可以不接收。如果要接收，必须使用相同/兼容的数据类型的变量来接收

### 5.4.5 return

1、形式一：return;

用于返回值类型是void的方法中，

作用是，提前结束当前方法的执行

return;语句是【可选】



2、形式二：return 返回值;

用于返回值类型不是void的方法中，

作用是，结束当前方法的执行，并且返回结果

return 返回值;是【必选】

### 5.4.6 方法的调用过程的内存分析

1、调用时，“入栈”

表示在栈中开辟一块独立的内存空间，用来存储这个方法的局部变量等。

2、调用结束后，“出栈”

表示释放该方法的栈空间

3、先调用的先入栈，后调用的后入栈



### 5.4.7 方法的参数传递机制

1、形参是基本数据类型

形参的修改和实参无关



2、形参是引用数据类型

通过形参修改“堆/方法区”的成员变量/元素的值的时候，会影响实参。

需要警惕：形参如果重新指向了新的对象，就和实参无关。



3、实参给形参赋值

形参是基本数据类型：copy了数据值

形参是引用数据类型：copy了对象的地址值，形参就可以通过这个地址值，操作实参在堆中的对象

### 5.4.8 局部变量与成员变量的区别

1、声明的位置

成员变量：在方法外

局部变量：方法内，包括在方法的(形参)和方法体{变量}



2、在内存中存储位置

成员变量：

* ​	静态变量：方法区
* ​	实例变量：堆

局部变量：栈



3、作用域

成员变量：没有作用域

​	在本类中：在静态方法中不能使用非静态成员变量

​	在其他类中：静态的建议使用“类名."，非静态的只能用"对象."

局部变量：有作用域



4、生命周期

静态变量：  和类一样，很久

实例变量：每一个对象是独立的，随着new在堆中分配，随着GC回收消亡

局部变量：方法调用时，到作用域开始，出了作用域结束



5、修饰符

成员变量：可以有修饰符

局部变量：除了final，不能有其他修饰符



### 5.4.9 可变参数

1、形式

```java
(数据类型... 形参名)

(数据类型 形参名,  数据类型... 形参名)
```

2、在声明可变参数的方法体中如何可变参数：当数组使用

3、在调用包含可变参数的方法时，可变参数对应的实参：

（1）可以是0~n个对应类型的元素

（2）可以是传入对应的数组

4、可变参数声明的要求

（1）一个方法最多只能有一个可变参数

（2）可变参数必须是形参列表最后一个



### 5.4.10 方法重载

在一个类，出现了两个或以上的 方法名相同， 形参列表不同（个数、数据类型）的方法。和返回值类型无关。



### 5.4.11 递归

当一个方法直接或间接的调用自己，就称为递归。

注意：

所有递归都必须有终止条件，否则就死循环，出现“栈内存溢出”。

同时递归就算有终止条件，递归的层次不宜太深，容易造成内存溢出，或者运行效率非常低。



## 5.5 对象数组

元素是引用数据类型时，这个数组就是对象数组。

例如：String[]，Student[]，Circle[]等

注意：

（1）第一步，创建数组对象本身

```java
元素类型[] 数组名 = new 元素类型[长度];
```

（2）第二步，创建元素对象

```java
数组名[下标] = new 元素类型();
```

（3）我们后面可以通过元素对象，调用成员变量、成员方法等

```java
System.out.println(数组名[下标].成员变量);
数组名[下标].方法(实参列表)
```

（4）如果要交换两个对象数组的元素

```
元素的类型  temp = 数组名[下标1];
数组名[下标1] = 数组名[下标2];
数组名[下标2] = temp;
```

> 这段代码没有产生新对象，只是借着temp这个变量，交换了两个元素中存储的对象地址。



# 第六章 面向对象基础（中）

## 6.1 面向对象的基本特征：封装

### 6.1.1 封装的好处？

1、调用者：方便使用/简化使用

2、设计者：安全，可控

### 6.1.2 如何实现封装，控制不同等级的封装

使用权限修饰符

| 修饰符    | 本类 | 本包 | 其他包的子类 | 其他包的非子类 |
| --------- | ---- | ---- | ------------ | -------------- |
| private   | √    | ×    | ×            | ×              |
| 缺省      | √    | √    | ×            | ×              |
| protected | √    | √    | √            | ×              |
| public    | √    | √    | √            | √              |

权限修饰符可以修饰什么？

所有的权限修饰符都可以修饰：成员变量、成员方法、构造器、成员内部类

可以修饰外部类的权限修饰符：缺省和public



### 6.1.3 属性私有化

1、在属性前面加private

2、根据需求提供get/set方法

```java
public class Student{
	private String name;
	private int age;
	private boolean marry;
	
	public void setName(String name){
		this.name = name;
	}
	public String getName(){
		return name;
	}
    public void setAge(int age){
        this.age = age;
    }
    public int getAge(){
        return age;
    }
    public void setMarry(boolean marry){
        this.marry = marry;
    }
    public boolean isMarry(){//boolean类型的属性，它的标准的get方法，用is代替get
        return marry;
    }
}
```

### 6.1.4 包

#### 1、包的作用

（1）控制可见性范围

如果在这个包中的某个类或成员，它的权限修饰符缺省了，就表示这个类或成员仅限于本包使用。

（2）避免类的重名

（3）按照不同的主题来分门别类管理类

因为包在编译后是对用文件夹。

常见的包：

java.lang：核心语言类库，例如：String。System，Math，Thread。。。

java.io：输入输出相关

java.util：各种工具

java.net：和网络编程相关

java.sql：和数据库相关

...



#### 2、如何声明包

```java
package 包名;
```

> 位置必须在.java文件的首行，一个.java文件只能有一句
>
> 包名的命名规范：（1）所有单词都小写，单词之间使用.分割（2）习惯上用公司域名倒置+模块名

例如：com.atguigu.xx；



#### 3、如何编译带包的源文件（了解）

```java
javac -d . 源文件名.java
```

* -d：创建包目录结构
* .：表示在当前目录



#### 4、如何运行代表的类（了解）

```java
java 包.类名
```



#### 5、如何使用其他包的类

（1）使用类的全名称

```java
java.util.Scanner input = new java.util.Scanner(System.in);
```

（2）使用import语句导包，在代码中使用简名称

```java
import 包名.类名;
import 包名.*; //*只能省略最后一级的类名

//静态导入
import static 包名.类名.静态成员;
import static 包名.类名.*;
```

> 当使用两个不同包，但是类名相同的两个类时，只能一个使用导包，一个使用全名称，不能两个都使用导包。
>
> 被使用的其他包的类或成员，它的权限修饰符必须是>缺省



## 6.2 初始化

### 6.2.1 初始化是干什么的？

目的：为成员变量初始化，赋值。



### 6.2.2 初始化的方式有四种

#### 1、默认值

#### 2、显式初始化

```java
【修饰符】 class 类名{
	【修饰符】 数据类型  成员变量 = 值;
}
```

#### 3、代码块

```java
【修饰符】 class 类名{
	static{
		//...静态代码块，给静态变量初始化
	}
	{
		//...非静态代码块，给实例变量初始化
	}
}
```

> 有的文章中人家把非静态代码块也叫构造块

#### 4、构造器

注意：构造器为实例变量初始化，一般不用它来为静态变量初始化。

> 有的文章中人家把构造器也称为构造方法

```java
【修饰符】 class 类名{
	【修饰符】 类名(){
		//无参构造
	}
	【修饰符】 类名(形参列表){
		//有参构造
	}
}
```

特点：

（1）所有类都有构造器

（2）如果一个类没有手动声明构造器，编译器会自动添加一个默认的无参构造；

​          如果我们手动声明了构造器，那么编译就不会自动添加无参构造了，如果需要，必须手动添加。

（3）构造器的名称必须和类名完全一致。

（4）构造器没有返回值类型

（5）构造器的修饰符：只能有权限修饰符（public,protected,缺省,private），不能有final,abstract,static等

### 6.2.3  初始化分为两类

#### 1、类初始化

作用：给静态变量初始化

类初始化本质上是在执行一个<clinit>()方法，这个方法是由编译自己组装而成的，编译会把：

（1）静态变量的显式赋值

（2）静态代码块中代码

按照代码编写的顺序进行组装。

每一个类的类初始化方法<clinit>()只会执行一次，第一次使用这个类的时候。

```java
public class Demo{
	private static int a = 1;
	static{
		System.out.println("静态代码块1");
	}
	private static int b = 1;
	static{
		System.out.println("静态代码块2");
	}
}
```

```java
//组装后
public class Demo{
	private static int a = 1;
	private static int b;
	<clinit>(){
		a = 1;
		System.out.println("静态代码块1");
		b = 1;
		System.out.println("静态代码块2");
	}
}
```



#### 2、实例初始化

作用：创建实例对象时，为实例变量初始化

本质上：实例初始化过程是在执行<init>(【...】)的实例初始化方法。

什么时候执行？每次new对象时执行

执行哪个？看你调用哪个构造器，看new后面。

一个类有几个实例初始化方法？看你这个类有几个构造器。

实例初始化方法<init>(【...】)，由编译自己组装而成：

* （1）实例变量的显式赋值
* （2）非静态代码块
* （3）构造器
* 其中（1）和（2）是按照顺序组装，（3）无论如何都在最后。而且（1）和（2）是在每一个实例初始化方法中都有，而（3）只找对应构造器的

```java
public class Demo{
	private int a = 1;
	{
		System.out.println("非静态代码块1");
	}
	private  int b = 1;
	public Demo(){
		System.out.println("无参构造");
	}
	public Demo(int a, int b){
		this.a = a;
		this.b = b;
		System.out.println("有参构造");
	}
	{
		System.out.println("非静态代码块2");
	}
}
```

```java
public class Demo{
	private int a;
	private  int b;
    
    <init>(){
        a = 1;
        System.out.println("非静态代码块1");
        b = 1;
        System.out.println("非静态代码块2");
        System.out.println("无参构造");
    }
    <init>(int a, int b){
        a = 1;
        System.out.println("非静态代码块1");
        b = 1;
        System.out.println("非静态代码块2");
        this.a = a;
		this.b = b;
		System.out.println("有参构造");
    }
}
```

#### 3、类初始化与实例初始化的顺序

一定是先完成类初始化，然后再实例初始化

## 6.3 继承

### 6.3.1 为什么要继承？

目的：

（1）代码复用：

​	   延续父类的特征

（2）代码的扩展：

​	  扩展父类没有的特征

（3）表示is-a的关系

​	  子类 is a 父类的派别。

​     例如：学生 is  a 人。



### 6.3.2 如何继承

语法格式：

```java
【修饰符】 class 父类{

}
【修饰符】 class 子类  extends 父类{

}
```

### 6.3.3 继承的特点

1、Java只支持单继承，每一个子类只有一个直接父类

2、Java支持多层继承，父类还可以有父类

3、子类会继承父类所有特征，包括成员变量、成员方法，哪怕是私有的，私有的在子类中无法直接使用。

4、子类不会继承父类的代码块、构造器等。

5、但是子类一定会调用父类的实例初始化方法。



### 6.3.4 继承时成员变量问题

1、子类会继承父类的所有的成员变量

> 子类创建对象时，在堆内存中是要为从父类继承的成员变量分配内存空间。

2、如果子类声明了与父类同名的成员变量

此时，如果想要访问父类的同名的成员变量，那么可以使用super.，但是前提条件，这个成员变量没有私有化。

如果私有化了，只能通过父类中的get/set来操作它。



### 6.3.5 继承时成员方法问题

1、子类会继承父类的所有的成员方法

2、如果父类的某个方法的方法实现不适用于子类，那么子类可以选择重写

重写的要求：

（1）方法名必须相同

（2）形参列表必须相同

（3）返回值类型

void和基本数据类型：必须相同

引用数据类型：<=

（4）权限修饰符：>=

（5）其他修饰符：不能重写子类中不可见的private，如果跨包的话，缺省的也不能被重写，

​								final，static



## 6.4  final

final：最终的

1、修饰类：不能被继承

2、修饰方法：不能被重写

3、修饰变量：值不能修改，即常量



## 6.5 this和super

### 6.5.1 this

1、this表示当前对象

2、它可以出现在：

（1）非静态代码块和构造器：this表示正在new的那个对象

（2）非静态方法：this表示调用这个方法的对象

3、用法：

（1）this.成员变量

* 当成员变量与局部变量同名时，在成员变量的前面加"this."
* 这个成员变量可以是本类声明的，也可以从父类继承的，但是要求是在子类中可见的成员变量并且是不和子类的成员变量同名

（2）this.成员方法

* 这个成员方法可以是本类声明的，也可以从父类继承的，但是要求是在子类中可见的成员方法，并且是没有重写。

（3）this()和this(实参列表)

* 只能访问本类的其他构造器
* 而且必须在构造器首行



### 6.5.2 super

1、super：表示当前对象中从父类继承的

2、通过super访问的成员变量、成员方法、构造器的，都必须在子类中可见

3、用法

（1）super.成员变量

* 当子类的成员变量与从父类继承的在子类中依然可见的成员变量同名时，可以使用"super.成员变量"来区别
* 当然，就算不同名，通过"super.成员变量"也可访问到从父类继承的在子类中依然可见的成员变量

（2）super.成员方法

* 当子类重写了父类的成员方法，又想要调用父类被重写的成员方法时，可以使用“super.成员方法"
* 当然，不重写的话，也可以通过“super.成员方法"来访问从父类中继承的在子类中依然可以见的成员方法

（3）super()或super(实参列表)

* 表示访问父类的实例初始化方法
* 而且必须在子类构造器的首行
* this()和this(实参列表)  与  super()或super(实参列表) 不能同时出现

### 6.5.3 就近原则

* super一定是从当前对象类型的直接父类开始找

* this一定是从当前对象类型的本类的成员开始找

* 即没有this又没有super，如果是变量一定是从局部变量开始找，如果是方法就从当前对象类型的本类的方法开始找



## 6.6 有继承情况下的初始化

### 6.6.1 类初始化

* 类初始化是执行<clinit>()方法，它的代码由两部分组成：
  * （1）静态变量的显式赋值
  * （2）静态代码块
  * 它俩是按照编写的顺序组装而成。

* 每一个类的类初始化方法只会执行一次。
* 子类初始化时会先检查父类，如果父类还没有初始化，会先完成父类的初始化，即先执行父类的<clinit>()方法

### 6.6.2 实例初始化

* 一个类可能会有1~n个的<init>方法，有几个看你声明了几个构造器；
* 实例初始化是执行对应的<init>方法，具体执行哪个，看你new后面调用的是哪个构造器；
* 实例初始化由以下四个部分组成：
  * ①super()或super(实参列表)  ==> 调用父类的对应的实例初始化方法，说明创建子类对象时，也会导致父类的实例初始化方法执行的
    * 其中super()或super(实参列表)是原先写在构造器首行的
  * ②实例变量的显式赋值
  * ③非静态代码块
  * ④构造器中的代码
    * 其中②和③是按代码中编写的顺序组装，①和④是一头一尾

* 实例初始化，每次new对象时执行，new一个执行一个

### 6.6.3 类初始化和实例初始化

如果第一次使用某个类时就是在创建对象，那么要先完成类初始化，然后再执行实例初始化。

## 6.8 抽象类

### 6.8.1 什么情况下会需要用到抽象类

1、在编写某个父类时，发现某个方法的方法体无法给出具体的实现，但是父类又需要声明这个方法以代表事物的特征，那么此时就只能把这个方法声明为抽象方法，一旦某个类包含抽象方法，那么这个类就必须是抽象类

2、在编写某个父类时，可能没有包含抽象方法，但是不希望用户创建这个父类的对象，希望用户创建它的子类对象时，那么也可以把这个父类声明为抽象类。



### 6.8.2 如何声明抽象类和抽象方法

抽象类的语法格式

```java
【其他修饰符】 abstract class 抽象类名{

}
```

抽象方法的语法格式：

```java
【其他修饰符】 abstract 返回值类型 方法名(【形参列表】);
```

> 抽象方法没有方法体



### 6.8.3 抽象类的特点

1、抽象类不能直接创建对象

2、抽象类就是用来被继承的，子类继承它时，必须重写/实现抽象类的所有抽象方法，否则子类也得时抽象类

3、抽象类也有构造器，给子类调用的

4、如果类中有抽象方法，那么必须是抽象类，但是反过来，抽象类中可以没有抽象方法。



## 6.9 多态

### 6.9.1 多态的概念

从逻辑意义上说，多态就是同一类事物的某一种行为，在不同的子类中表现出不同的形态。例如：求面积，不同的图形，求面积的方式不同。

从语法角度来说，多态就是在运行期间才能确定调用哪个类的方法，即执行子类重写的方法。



### 6.9.2 多态的前提

1、继承

2、重写

* ​	静态方法
* ​	final方法
* ​	private方法
* 属性

这些不能重写的就不可能有多态（即静态绑定）。只有能重写的方法才有多态（即动态绑定）。

3、多态引用/向上转型

​	父类的变量/形参  指向了子类的对象



### 6.9.3 多态的现象

编译时看父类，即通过父类的变量只能引用父类中有的方法

运行时看子类对象，即运行时一定执行子类“重写”的方法



### 6.9.4 多态的应用

1、多态数组

​	元素的类型是父类的类型，存进去的元素对象是子类的对象

2、多态参数

​	形参是父类的类型，传入的实参是子类的对象



### 6.9.5 类型转换

#### 1、向上转型upcasting

当把子类的对象赋值给父类的变量/形参时，就会发生向上转型。

向上转型的后果，在编译期间只能调用父类中有的方法、成员变量等。

#### 2、向下转型downcasting

当想要调用子类特有的方法时，需要把这个父类的变量再向下转型为子类的类型。

向下转型有风险，可能会发生ClassCastException异常，如果想要避免这个异常，最好在向下转型之前，用instanceof进行判断。

```java
class Person{
	//...
}
class Man extends Person{
	//...
}
class Woman extends Person{
	//...
}
class ChineseMan extends Man{
	///
}
```

```java
Person p1 = new Person();
Person p2 = new Man();
Person p3 = new Woman();
Person p4 = new ChineseMan();
Man m5 = new ChineseMan();

//把以上上面的5个对象转为ChineseMan类型，哪些向下转型会成功？
ChineseMan c1 = (ChineseMan) p1;//ClassCastException
ChineseMan c2 = (ChineseMan) p2;//ClassCastException
ChineseMan c3 = (ChineseMan) p3;//ClassCastException
ChineseMan c4 = (ChineseMan) p4;//可以
ChineseMan c5 = (ChineseMan) m5;//可以

if(p1 instanceof Person)  true
if(p1 instanceof Man)	  false 
if(p1 instanceof Woman)   false
    
if(p2 instanceof Person)  true
if(p2 instanceof Man)	  true 
if(p2 instanceof Woman)   false  
    
if(p4 instanceof Person)  true
if(p4 instanceof Man)	  true 
if(p4 instanceof Woman)   false     
if(p4 instanceof ChineseMan)   true 
```

> 无论是向下转型还是instanceof，父类的变量中一定执行的对象的实际类型是<=向下转型或判断的类型。
>
> 例如：p4指向的是ChineseMan的对象，它是<=Person,<=Man,<=ChineseMan



## 6.10 关键字：native

native：原生的，本地的

native：用来修饰方法。表示这个方法的方法体不是用Java语言实现的，而是用C/C++语言实现的，编译为.dll文件，由Java代码进行调用。

在Java层面使用native的方法和使用普通的Java方法一样。如果是非静态的，那么使用“对象”调用，如果是静态的，那么使用“类名”调用，如果子类继承后想要重写，也可以使用Java代码进行重写。

在运行时native方法的入栈是在本地方法栈，Java实现的方法的入栈是在虚拟机栈。



## 6.11 java.lang.Object类

### 6.11.1 根父类

Object类是所有类型的超类，即根父类。包括数组类型在内的所有引用数据类型。

如果一个类没有显式的声明它的直接父类，那么它的父类就是Object。

所有的对象（包括数组对象）都可以调用从Object类继承的方法（11个）。

Object类型的变量/形参可以赋值为任意类型的对象。



### 6.11.2 Object类的几个方法

#### 1、toString()

public String toString()：把一个对象的信息用一个字符串表示，尽量要能够简单易懂，建议子类重写。

如果没有重写，默认 “类型名@对象hashCode的十六进制值”。

eclipse中Alt +Shift +S，选择toString。



注意：当我们打印一个对象，或者一个对象与String数据进行拼接是，都会自动调用这个对象的toString。



#### 2、getClass()

public Class<?> getClass()：获取对象的“运行时”类型。



#### 3、finalize()

public void finalize()：

什么时候调用？谁调用？调用特定是什么？

当一个对象被确定为垃圾时，由GC垃圾回收器来进行调用，每一个对象的finalize()方法只会被调用一次。

一般是与系统有关的资源对象需要重写这个方法。



#### 4、hashCode()

public int hashCode()：返回一个对象的hashCode值。

常规协定：

（1）如果一个对象的参与计算hashCode值的成员变量没有修改，那么在程序运行期间，每次获取的hashCode值不变。

（2）如果两个对象hashCode不同，那么这两个一定不“相等”

（3）如果两个的hashCode值相同，那么这两个对象不一定“相等”

（4）如果两个相等，那么他们的hashCode值一定要相同。



#### 5、equals()

public boolean equals(Object obj)：用于判断当前对象与指定对象是否相等。

默认的实现，等价于“==”，比较对象的内存地址。

我们子类可以选择重写，重写有一些要求：

（1）重写equals时，一定要重写hashCode方法

（2）还需要遵循几个原则：

A：一致性：如果参与equals比较的成员变量没有修改，在程序运行期间比较的结果不变。

B：对称性：x.equals(y)与y.equals(x)的结果一致

C：自反性：x.equals(x)一定返回true

D：传递性：x.equals(y)如果是true，y.equals(z)如果是true，那么x.equals(z)也是true

E：非空对象与null的equals一定是false

eclipse中Alt +Shift +S，选择generate  hashCode和equals....

# 第七章 面向对象基础（下）

## 7.1 枚举

### 7.1.1 枚举是一种特殊的类

特殊：它的对象是有限固定的几个常量对象。



### 7.1.2 如何声明枚举

JDK1.5之前没有枚举的概念，但是可以实现这种效果：

（1）把构造器私有化

（2）在类型的内部使用几个静态的常量来保存它的对象

```java
public Season{
	public static final Season SPRING = new Season();
	public static final Season SUMMER = new Season();
	public static final Season FALL = new Season();
	public static final Season WINTER = new Season();
	
	private Season(){
	
	}
}
```

JDK1.5之后开始有枚举的概念，实现比较简单：

```java
【修饰符】 enum 枚举类型{
	常量对象列表;
	其他成员列表
}
```

要求：

（1）常量对象列表;   必须在首行

（2）如果枚举的常量对象列表后面没有其他成员，那么结尾的;可以省略，但是如果后面还有其他成员，那么;不能省略。

（3）枚举类型的构造器，只能使用private修饰，那么你省略private也是私有的。

```java
public enum Week{
	MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY
}
```

```
public enum Week{
	MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;
	private String description;
	//...
}
```



首行：

（1）super()或super(实参列表)：调用父类的构造器，本质上是调用父类的实例初始化方法<init>

（2）this()或this(实参列表)：调用本类的其他构造器

（3）package 语句，在源文件的首行。

（4）枚举类型的常量对象在枚举类的首行



### 7.1.3 枚举类型的其他特点

* 枚举类型有一个公共的基类：java.lang.Enum类，即枚举类型不能再继承别的类型。

Enum类只有一个唯一的构造器：

```java
protected Enum(String name, int ordinal)
```

name代表的是常量对象名，ordinal代表的是常量对象的序号。

* 它的toString()默认返回的是常量对象名，如果要重写，只能手动重写，不能使用eclipse的toString生成。

* 还有两个API中没有的方法：
  * 枚举类型[] values():
  * 枚举类型  valueOf("常量对象名")
* switch在JDK1.5之后，对枚举开始支持。switch(表达式)其中的表达式可以是枚举类型的变量，case后面写枚举的常量对象名。



## 7.2 包装类

### 7.2.1 为什么要有包装类

Java中的很多特性和API不支持基本数据类型，因为基本数据类型不是对象。所以我们必须把基本数据类型的数据使用它们的包装类进行包装。



### 7.2.2 包装类有哪些

| 基本数据类型 | java.lang包装类 |
| ------------ | --------------- |
| byte         | Byte            |
| short        | Short           |
| int          | Integer         |
| long         | Long            |
| float        | Float           |
| double       | Double          |
| char         | Character       |
| boolean      | Boolean         |
| void         | Void            |

  

### 7.2.3 类型转换

#### 1、装箱与拆箱

装箱：把基本数据类型-->包装类对象

​	手动装箱：例如：new Integer(int值) 或 Integer.valueOf(int值)

​	自动装箱：Integer i = int值;

拆箱：把包装类的对象-->基本数据类型

​	手动拆箱：例如：Integer的对象.intValue()

​	自动拆箱：int i = Integer的对象;



#### 2、基本数据类型与字符串之间转换

* 基本数据类型-->字符串：  直接+""
* 字符串-->基本数据类型：
  * Integer.parseInt(字符串)
  * Double.parseDouble(字符串)
  * ....



### 7.2.4 包装类有缓存对象

| Byte      | -128~127   |
| --------- | ---------- |
| Short     | -128~127   |
| Integer   | -128~127   |
| Long      | -128~127   |
| Float     | 没有       |
| Double    | 没有       |
| Character | 0~127      |
| Boolean   | true,false |



### 7.2.5 包装类对象不可变

一旦修改就是新对象。

容易出现在面试题的“方法的参数传递”类型的题目中。

```java
public static void change(Integer value){
	value = xxx;
}
public static void main(String[] args){
	Integer i = 10;
	change(i);
	System.out.println("i=" + i);//10
}
```



## 7.3 接口

### 7.3.1 概念

接口是一种标准，行为规范。比抽象类还要抽象的类型。

最早接口中都是抽象方法，没有具体方法，从JDK1.8之后，开始支持默认方法，静态方法，从JDK1.9之后又增加私有方法。



### 7.3.2 如何声明接口

语法格式：

```java
【修饰符】 interface 接口名{
	//...
}
```



### 7.3.3 接口的成员

#### 1、公共的静态的常量：public static final

#### 2、公共的抽象的方法：public abstract

​	非抽象的实现类必须重写

#### 3、公共的默认方法：public default，JDK1.8之后

​	使用“实现类的对象."进行调用

​	实现类可以选择重写

#### 4、公共的静态方法：public static， JDK1.8之后

​	只能使用”接口名.“进行调用

​	实现类不能重写

#### 5、私有的方法：private（private不能省略）JDK1.9之后



关于默认方法可能有冲突问题：

（1）一个实现类实现了多个接口，而多个接口中出现了方法签名相同的默认方法时：

实现类必须做出选择：

A：保留其中一个：接口名.super.方法名

B：也可以完全重写

（2）一个实现类既继承父类，又实现接口，当父类中出现与接口的默认方法的方法签名相同的方法：

A：默认遵循亲爹原则，即保留父类的

B：也可以完全重写



### 7.3.4 接口的其他特点

#### 1、接口不能直接创建对象

#### 2、一个类能同时实现多个接口

```java
【修饰符】 class 实现类 [extends 父类] implements 接口们{

}//继承在前，实现在后
```

> 实现类实现接口时，必须重写接口的所有抽象方法，否则实现类就必须是抽象类。

#### 3、接口与接口之间支持多继承

```java
【修饰符】 interface 接口 extends 接口们{

}
```

### 7.3.5 常见的接口

#### 1、java.lang.Comparable接口：自然排序

它的抽象方法：

```java
int compareTo(Object obj)

规则：
    当前对象this  大于 指定对象obj  返回正整数
    当前对象this  小于 指定对象obj  返回负整数
    当前对象this  等于 指定对象obj  返回0
```

哪个类的对象需要比较大小，排序，哪个类就实现这个接口即可。

```java
class Student implements Comparable{
	private int id;
	private String name;
	private int score;
	//....
	public int compareTo(Object obj){
		Student other = (Student)obj;
		//例如：按照学号比较
		return this.id - other.id;
	}
}
```

```java
Student s1 = new Student(....);
Student s2 = new Student(....);

if(s1.compareTo(s2)>0){
    //...
}else if(s1.compareTo(s2)<0){
    //..
}else{
    //...
}
```

```java
Student[] arr = new Student[5];
//....

Arrays.sort(arr);//按照Student的compareTo方法实现的排序规则进行排序
```



#### 2、java.util.Comparator接口：定制排序、挽救的排序

抽象方法：

```java
int compare(Object o1, Object o2)
```

> 用  比较器对象.compare(要比较大小的对象1， 要比较大小的对象2)

当某个类的对象不支持自然排序或者是自然排序规则不符合当前的需求时，可以单独使用定制比较器进行排序。

```java
//它的自然排序是按照学号比较大小
//新的需求是要求按照分数比较大小，如果分数相等，再按照学号比较，这个时候就可以单独再编写一个Commparator接口的实现类
class StudentScoreComparator implements Commparator{
	public int compare(Object o1, Object o2){
		Student s1 = (Student)o1;
		Student s2 = (Student)o2;
		if(s1.getScore() != s2.getScore()){
			return s1.getScore() - s2.getScore();
		}
		return s1.compareTo(s2);
	}
}
```

```java
Student s1 = new Student(....);
Student s2 = new Student(....);

StudentScoreComparator ssc = new StudentScoreComparator();

if(ssc.compare(s1,s2)>0){
    //...
}else if(ssc.compare(s1,s2)<0){
    //..
}else{
    //...
}
```

```java
Student[] arr = new Student[5];
//....

StudentScoreComparator ssc = new StudentScoreComparator();
Arrays.sort(arr,ssc);//按照StudentScoreComparator的compare方法实现的排序规则进行排序
```

#### 3、java.lang.Cloneable接口

如果某个类想要重写Object类的clone()来支持对象的克隆功能，那么要求这个类型必须实现java.lang.Cloneable接口，这个接口没有抽象方法，只是一个标识型接口，如果不实现这个接口，调用clone()时，会报CloneNotSupportedException。

## 7.4 内部类

### 7.4.1 什么情况下需要用内部类

当在描述一个比较复杂的事物时，发现它的内部需要另一个完整的结构来辅助它的描述。这个内部的结构只为外部类服务，并且需要直接访问外部类的私有的数据等的时候，这样的情况就可以把这个内部的结构声明为内部类。



### 7.4.2  内部类的分类

#### 1、成员的内部类：声明在外部类中方法外

有static修饰的：静态成员内部类，简称静态内部类

没有static修饰的：非静态成员内部类，一般说的成员内部类就是它

#### 2、局部的内部类：声明在外部类的方法体中

分为有名字的局部内部类和匿名的局部内部类



### 7.4.3 静态内部类

1、语法结构：

```java
【修饰符】 class 外部类  【extends 父类】  【implements 接口们】{
	【其他修饰符】 static class 静态内部类  【extends 父类】  【implements 接口们】{
	}
}
```

> 外部类的权限修饰符：public或缺省，其他修饰符：abstract或final
>
> 静态内部类的权限修饰符：四种，其他修饰符：abstract或final + static

2、静态内部类也是类

（1）可以有自己的父类或父接口

（2）有自己的字节码文件：外部类名$静态内部类名.class

（3）有自己的成员：没有限制

​	只要在类中可以写的成员它都可以有，只有静态内部类允许有静态成员。

3、静态内部类的使用

（1）静态内部类使用外部类的成员时：

有限制：静态内部类不能使用外部类的非静态成员

（2）在外部类中使用静态内部类

使用静态内部类的静态成员：直接使用“静态内部类名."

使用静态内部类的非静态成员：使用“静态内部类的对象."

（3）在外部类的外面使用静态内部类

前提：这个静态内部类在外面是可见，否则只能通过这个静态内部类的父类或父接口来引用它的对象。

如果可见，使用静态内部类的静态成员：直接使用“外部类名.静态内部类名."

​		            使用静态内部类的非静态成员：使用“静态内部类的对象."

```java
外部类.静态内部类  对象名 = new  外部类.静态内部类(【...】);
```

### 7.4.4 非静态内部类

1、语法结构：

```java
【修饰符】 class 外部类  【extends 父类】  【implements 接口们】{
	【其他修饰符】 class 非静态内部类  【extends 父类】  【implements 接口们】{
	}
}
```

> 外部类的权限修饰符：public或缺省，其他修饰符：abstract或final
>
> 非静态内部类的权限修饰符：四种，其他修饰符：abstract或final 

2、非静态内部类也是类

（1）可以有自己的父类或父接口

（2）有自己的字节码文件：外部类名$非静态内部类名.class

（3）有自己的成员：有限制

​	不能有静态成员，除非静态常量。

3、非静态内部类的使用

（1）非静态内部类使用外部类的成员时：没有限制

（2）在外部类中使用非静态内部类

​	在外部类的静态成员中使用无法使用非静态内部类的。

​     在外部类的非静态成员中使用非静态内部类，使用“非静态内部类的对象."

（3）在外部类的外面使用非静态内部类

前提：这个非静态内部类在外面是可见，否则只能通过这个非静态内部类的父类或父接口来引用它的对象。

如果可见，使用非静态内部类的非静态成员：要求必须有外部类的对象的引用

```java
//原始写法
外部类 out = new 外部类(【...】);
外部类.非静态内部类  对象名 = out.new  非静态内部类(【...】);


class Outer{
    class Inner{
        //...
    }
}

Outer out = new Outer();
Outer.Inner in = out.new Inner();
```

```java
//在实际开发中，在外部类中编写一个方法来返回非静态内部类的对象，然后调用这个方法来获取非静态内部类对象
class Outer{
	class Inner{
		//...
	}
	
	public Inner getInner(){
		return new Inner();
	}
}

Outer out = new Outer();
Outer.Inner in = out.getInner();
```

### 7.4.5 有名字的局部内部类

1、语法结构：

```java
【修饰符】 class 外部类  【extends 父类】  【implements 接口们】{
    【修饰符】 返回值类型 方法名(【形参列表】){
        【abstract或final或没有】 class 局部内部类  【extends 父类】  【implements 接口们】{
		}
    }
}
```

> 外部类的权限修饰符：public或缺省，其他修饰符：abstract或final
>
> 局部内部类没有权限修饰符，其他修饰符：abstract或final 

2、局部内部类也是类

（1）可以有自己的父类或父接口

（2）有自己的字节码文件：外部类名$编号局部内部类名.class

（3）有自己的成员：有限制

​	不能有静态成员，除非静态常量。

3、局部内部类的使用

（1）局部内部类使用外部类的成员时：有限制

​	能否使用外部类的非静态成员，看所在的方法是否是静态的，如果是静态就不能用。

（2）在外部类中使用局部内部类

​	有作用域，即只能在这个方法体中，并且在声明之后。

（3）在外部类的外面使用局部内部类：不能

（4）在外部类的外面可以得到局部内部类的对象

但是需要通过它的父类或父接口的变量来引用，用方法的返回值返回。

（5）在局部内部类中如果要使用外部类的局部变量，需要有final。

### 7.4.6 匿名内部类

1、语法格式

```java
new 父类(){
	//可以写方法....
}
new 父类(实参列表){
	//可以写方法....
}
new 父接口(){
	//可以写方法....
}
```

2、匿名内部类的对象一般会三种形式使用它

```java
父类/父接口  变量 = new 父类/父接口(【实参列表】){
	//可以写方法....
};
```

```
new 父类/父接口(【实参列表】){
	//可以写方法....
}.方法(【实参列表】);
```

```java
方法名(new 父类/父接口(【实参列表】){
	//可以写方法....
});
```

```
interface A{
	void a();
}

A obj = new A(){
	public void a(){
		//....
	}
};
obj.a();
```

```
new Object(){
	public void method(){
		//...
	}
}.method();
```

```java
interface A{
	void a();
}

class Test{
	public static void main(String[] args){
		method(new A(){
            public void a(){
                //....
            }
        });
	}
	public static void method(A a){
		a.a();
	}
}
```

## 7.5 注解

### 7.5.1 注解也是一种注释

（1）和普通注释相同：它本身不会改变程序的逻辑，只是对程序添加一些注释性的内容

（2）和普通注释不同：注解的注释内容是可以被另一段程序读取的



一个完整的注解应该有三个部分：

（1）声明：   @interface

（2）使用：   @注解名    或     @注解名(....)

（3）读取：   

* SOURCE：只能由编译器读取
* CLASS：可以由类加载器读取
* RUNTIME：可以通过反射的代码在运行时读取



### 7.5.2 系统的三个最基本的注解

#### 1、@Override

（1）用在重写的方法上

（2）让编译器帮我们检查这个方法是否遵循重写的要求

* 方法名：相同
* 形参列表：相同
* 返回值类型：
  * ​	基本数据类型和void：相同
  * ​	引用数据类型：<=
* 权限修饰符：>=
* 其他修饰符：不能是static,final,private
* throws：
  * 如果父类被重写的方法没有抛出编译时异常，那么重写的方法也不能抛
  * 如果父类被重写的方法抛出了编译时异常，那么重写的方法只能抛出<=它的异常



#### 2、@Deprecated

（1）用在已过时的xx上面



#### 3、@SuppressWarnings

（1）用于抑制警告

（2）格式

```java
@SuppressWarnings("all")
@SuppressWarnings("uncheck")
@SuppressWarnings({"unused","uncheck"})
...
```



### 7.5.3 JUnit的几个注解

标记在公共的类，方法需要是公共的、无参、无返回值的。

#### 1、@Test：表示单元测试方法

#### 2、@Before：在每一个单元测试方法之前运行

#### 3、@After：在每一个单元测试方法之后运行

#### 4、@BeforeClass：在所有测试方法之前运行，只运行一次，方法必须是static

#### 5、@AfterClass：在所有测试方法之后运行，只运行一次，方法必须是static



### 7.5.4 四个元注解

元注解：给注解加注解信息的注解

#### 1、@Target：指定注解的使用位置

@Target的位置由ElementType枚举类型的10个常量对象来指定

```java
@Target(ElementType.METHOD)
@Target({ElementType.METHOD,ElementType.FIELD, 。。。。})
```



#### 2、@Retention：指定注解的滞留阶段

@Retention的阶段由RetentionPolicy枚举类型的3个常量对象来指定

```java
@Retention(RetentionPolicy.SOURCE)
@Retention(RetentionPolicy.CLASS)
@Retention(RetentionPolicy.RUNTIME)
```



#### 3、@Documented：标记这个注解是否要被记录到javadoc文档中

#### 4、@Inherited：标记这个注解是否可以被子类继承



### 7.5.5 自定义注解

1、语法格式

```java
@元注解
【修饰符】 @interface 注解名{
	
}

或

@元注解
【修饰符】 @interface 注解名{
	数据类型  参数名1();
	数据类型  参数名2() default 默认值;
}
```

2、配置参数的要求

（1）声明时，类型有要求：

8种基本数据类型、String、枚举、Class、注解，以及他们的数组

（2）使用时，

只要声明了参数，使用这个注解时，就要为它赋值，赋值的格式：(参数名1=参数值，参数名2=参数值)

当参数名是value时，可以省略“value=”

当参数有默认值，也可以不赋值

# 第八章 异常

## 8.1 异常的概念

程序正常情况下可以顺利运行，可能会遇到：用户非法输入、文件找不到、磁盘空间已满、数据库连接错误等问题，如果程序不处理，就会崩溃。



## 8.2 异常的类型

### 1、异常的根类型：java.lang.Throwable

* 只有它或它的子类的实例对象，才能被JVM或throw语句给“抛”出；
* 也只有它或它的子类类型，才能用于catch(异常类型 e)语句中的异常类型，用于“捕获”异常

换句话说，如果要自定义异常，必须继承Throwable或它的子类



### 2、Throwable的两大子类：Error和Exception

Error：合理的应用程序不应该通过捕获来解决的严重错误。例如：VirtualMachineError虚拟机错误（StackOverflowError栈溢出，OutOfMemoryError堆内存溢出）

Exception：合理的应用程序应该通过代码避免或捕获来解决的异常。



### 3、Exception的两大类：编译时异常和运行时异常

* 运行时异常：RuntimeException或它的子类
  * 例如：ArrayIndexOutOfBoundsException数组下标越界异常
  * 例如：NullPointerException空指针异常
  * 例如：ClassCastException：类型转换异常
  * 例如：ArithmeticException：算术异常
  * 例如：InputMismatchException：输入不匹配异常
  * 例如：NumberFormatException：数字格式化异常
* 编译时异常：除了运行时异常都是编译时异常
  * 例如：IOException：输入输出异常
  * 例如：FileNotFoundException：文件找不异常
  * 例如：SQLException：sql执行错误



### 8.3 和异常处理相关的几个关键字

### 8.3.1 关键字介绍

1、try：尝试执行可能会发生异常的代码

2、catch：尝试捕获try中发生的异常

3、finally：无论try中是否发生异常，也无论catch是否可以捕获异常，也不管try和catch中是否有return语句，都要执行。除非在try或catch中执行了System.exit（0）语句。

4、throw：用于手动抛出异常

5、throws：表示某个方法内部没有处理xx异常，抛给调用者处理，在方法的签名中显式声明抛出哪些异常



### 8.3.2 语法结构

1、try..catch

```java
try{
	可能发生异常的代码
}catch(异常类型  e){
	处理异常的代码
    //打印，或什么都不写，或者其他处理代码
}catch(异常类型  e){
	处理异常的代码
    //打印，或什么都不写，或者其他处理代码
}。。。
```



2、try...catch...finally

```java
try{
	可能发生异常的代码
}catch(异常类型  e){
	处理异常的代码
    //打印，或什么都不写，或者其他处理代码
}catch(异常类型  e){
	处理异常的代码
    //打印，或什么都不写，或者其他处理代码
}finally{
	...
}
```

3、try...finally

```java
try{
	可能发生异常的代码
}finally{
	...
}
```



4、throw的语法格式

```java
throw new 异常类型(message);
```



5、throws的语法格式

```java
【修饰符】 返回值类型  方法名(【形参列表】)throws 异常列表{//方法签名，方法头
		方法体
}
```

## 8.3 自定义异常

要求：

1、必须继承Throwable或它的子类，一般继承Exception或RuntimeException

2、尽量保留两个构造器：无参和有参(message)

3、加序列化版本ID

4、自定义异常类型的对象只能使用throw语句抛出

# 第九章 多线程

## 9.1 相关的概念

程序（programm）：为了完成某个功能或任务，选择某种编程语言编写的一组指令的集合。

软件（software）：是一个或多个的程序+程序需要的一些素材，文档等其他的资料构成一个完整的软件。

进程（process）：是一个程序的一次运行，操作系统以进程为基本单位来分配资源等。每一个进程之间内存是独立。

线程（thread）：是一个进程中的其中一条执行路径，CPU调度的最基本调度的单位。同一个进程中线程可以共享一些内存（堆、方法区），每一个线程又有自己的独立空间（栈、程序计数器）。因为线程之间有共享的内存，在实现数据共享方面，比较方便，但是又因为共享数据的问题，会有线程安全问题。



## 9.2 两种实现线程的方式

### 9.2.1 继承Thread类

1、步骤：

（1）编写线程类，继承Thread

（2）重写public void run()方法，它的方法体就是这个线程的线程体（这个线程要完成的任务）

（3）创建线程类对象

（4）启动：必须调用start()

```java
class MyThread extends Thread{
	public void run(){
		//....
	}
}
class Test {
	public static void main(String[] args){
		MyThread my1 = new MyThread();
		my1.start();
		
		MyThread my2 = new MyThread();
		my2.start();
	}
}
```

```java
new Thread(){
	public void run(){
		//....
	}
}.start();
```

```java
Thread t = new Thread(){
	public void run(){
		//....
	}
};
t.start();
```

### 9.2.2 实现Runnable接口

1、步骤：

（1）编写线程类，实现Runnable接口

（2）重写public void run()方法，它的方法体就是这个线程的线程体（这个线程要完成的任务）

（3）创建线程类对象

（4）启动：必须调用start()

借助Thread类的对象

```java
class MyRunnable implements Runnable{
	public void run(){
		//....
	}
}
class Test {
	public static void main(String[] args){
        MyRunnable target = new MyRunnable();
        
		Thread my1 = new Thread(target);
		my1.start();
		
		Thread my2 = new Thread(target);
		my2.start();
	}
}
```

```java
Runnable target = new Runnable(){
	public void run(){
		///....
	}
};
Thread t = new Thread(target);
t.start();
```

```java
new Thread(new Runnable(){
	public void run(){
		///....
	}
}).start();
```

### 9.2.3 两种方式的区别

1、继承的方式有单继承的限制，实现的方式可以多实现

2、启动方式不同

3、继承的方式，在实现共享数据时，可能需要静态的

​       实现的方式，只要共享同一个Runnable实现类的对象即可。

4、继承的方式，选择锁时this可能不能用，

​      实现的方式，选择锁时this可以用。



## 9.3 Thread类API

### 1、构造器

Thread()

Thread(String name)

Thread(Runnable target)

Thread(Runnable target,String name)



### 2、其他方法

（1）启动：start()，每一个线程对象只能调用一次

（2）run()：必须重写

（3）static void sleep(时间)：线程休眠

（4）void join()：加塞，这句代码出现在哪个线程（例如：A）的线程体中，调用join()方法的线程对象（例如：B）会将A阻塞，只有B结束，A才能恢复。

​          void join(时间)：加塞，这句代码出现在哪个线程（例如：A）的线程体中，调用join()方法的线程对象（例如：B）会将A阻塞，时间到后，A才能恢复。

（5）static void yield()：这句代码出现在哪个线程（例如：A）的线程体中，当A线程运行到这句yield()代码时，会暂停运行，让出CPU，重新开始和其他线程竞争CPU。

（6）getName()/setName()：设置和获取线程名称

（7）getPriority()/setPriority()：设置和获取线程的优先级。优先级必须在[1,10]之间。有三个常量：MAX_PRIORITY（10），MIN_PRIORITY（1），NORM_PRIORITY（5）。优先级时影响使用了抢占式策略的调度机制时CPU调度的概率。

（8）boolean isAlive()：判断某个线程是否处于活动状态（已启动还未死亡）。

（9）void setDaemon(boolean)：设置某个线程是否为守护线程（守护线程为其他非守护服务的，当其他非守护线程死亡了，它自动死亡）。

（10）static Thread currentThread()：获取当前线程对象。



## 9.4 关键字

volatile：用它修饰的变量，不一定在什么时候值就会被修改了，为了总是得到最新的值，那么每次都从主存中去取值，不要在寄存器中缓存它的值。



## 9.5 线程安全

### 9.5.1 线程安全问题的判断

1、是否有多个线程

2、这多个线程是否使用共享数据

3、这些线程在使用共享数据时，是否有写有读操作



### 9.5.2 如何解决？同步

#### 1、同步代码块

语法格式：

```java
synchronized(锁对象){
	需要同步的代码
}
```

锁对象由我们程序员选择，如何选择？

（1）必须是对象，不能是基本数据类型

（2）这个锁对象，必须保证多个线程之间使用的是同一个

#### 2、同步方法

语法格式：

```java
【其他修饰符】 synchronized 返回值类型 方法名(【形参列表】)【throws 异常列表】{

}
```

锁对象不能由我们自己选，它是默认的：

（1）静态方法：锁对象是当前类的Class对象

（2）非静态方式：this



## 9.6 线程通信

### 9.6.1 解决什么问题？生产者与消费者问题

一些线程负责往“数据缓冲区”填充数据，我们称为“生产者”，

另一个线程负责从“数据缓冲区”取数据，我们称为“消费者”，

当“数据缓冲区”满的时候，“生产者”需要wait，等着被唤醒；

当“数据缓冲区”空的时候，“消费者”需要wait，等着被唤醒。



生产者与消费者问题中，还隐含线程安全问题。因为“数据缓冲区”是共享的，而且有读取有写入的，所以有安全问题。



### 9.6.2 如何解决

java.lang.Object类的方式：

（1）wait()：等待

（2）notify()/notifyAll()：唤醒

它们都必须由“锁/对象监视器”来调用，否则就会报错。



思考：为什么wait()和notify()方法是声明在Object类中，而不是Thread类中？

因为锁对象可能是任意引用数据类型的对象，我们为了保证任意对象都有wait和notify方法，所以只能设计在Object类中。



面试题：sleep()和wait()方法的区别？

（1）sleept()声明在Thread类中，而且是静态方法；

​        wait()声明在Object类中，而且必须由锁对象调用。

（2）sleep()时间到恢复；

​		 wait()可以设置时间自动恢复，如果没有设置时间必须由notfiy来唤醒；

（3）sleep()不会使得这个线程失去锁；

​         wait()会使得当前这个线程失去锁，让其他线程执行同步代码块或同步方法。



## 9.7 线程的生命周期

### 9.7.1 观点1：5种

1、新建：创建了线程对象，还未start

2、就绪：已启动，并且可被CPU调度

3、运行：正在被调度

4、阻塞：遇到了：sleep(),wait(),wait(time),其它线程的join()，join(time)，suspend()，锁被其他线程占用等

​			     解除阻塞回到就绪状态：sleep()时间，notify()，wait的时间到，加塞的线程结束，加塞的时间到，resume()，其他占用锁的线程释放了锁等。

5、死亡：run()正常结束，遇到了未处理的异常或错误，stop()

![](D:/尚硅谷/备课资料/JavaSE练习和复习笔记/JavaSE复习笔记/imgs/1563282798989.png)

### 9.7.2 观点2：6种

1、新建NEW：创建了线程对象，还未start

2、可运行RUNNABLE：可以被CPU调度，或者正在被调度

3、阻塞BLOCKED：等待锁

4、等待WAITING：wait(),join()等没有设置时间的，必须等notify()，或加塞的线程结束才能恢复

5、有时间等待TIMED_WAITING：sleep(time)，wait(time)，join(time)等有时间的阻塞，等时间到了恢复，或被interrupt也会恢复

6、终止TERMINATED：run()正常结束，遇到了未处理的异常或错误，stop()

![1563381997032](D:/尚硅谷/备课资料/JavaSE练习和复习笔记/JavaSE复习笔记/imgs/1563381997032.png)

## 9.8 锁

### 9.8.1  如何选择锁

### （SE阶段）synchronized

1、锁必须是对象

2、保证多个线程共用同一个锁



### 9.8.2 哪些操作会释放锁，哪些不会释放锁

会释放锁：

1、线程死亡

2、wait()

不会释放锁：

1、sleep()

2、yield()

### 9.8.3 死锁

两个或多个线程，互相持有对方想要的锁对象不放手

# 第十章 常用API和基础算法

## 10.1 和数学相关

### 1、java.lang.Math类

* abs(x)：求绝对值
* sqrt(x)：求平方根
* pow(x,y)：求x的y次方
* ceil(x)：向上取整
* floor(x)：向下取整
* round(x)：四舍五入
* random()：得到[0,1)范围的随机值
* max(x,y)：求x,y的最大值
* min(x,y)：求x,y的最小值
* PI：圆周率



### 2、java.math包

* BigInteger：不可变，任意精度的整数

* BigDecimal：不可变，任意精度的小数

* 它们要new对象来表示数据，要通过add,subtract,multiply,divide等方法来进行算术运算

  



### 3、java.util.Random

```java
Random r = new Random();

double d = r.nextDouble();//[0,1)
int i = r.nextInt();//int范围内
int j = r.nextInt(x);//[0，x)范围内的整数
```



## 10.2 日期时间相关

### 10.2.1 java.util.Date

* new Date()：获取系统日期时间
* new Date(long 毫秒)：根据毫秒值来获取日期时间
* long getTime()：获取该日期时间对应的毫秒值，距离1970-1-1 0:0:0



### 10.2.2 java.util.Calendar

如何创建/获取Calendar的对象？

（1）创建子类对象：GregorianCalendar

（2）获取指定时区的日历对象：  

* ​	getInstance()
* ​	getInstance(TimeZone 时区) 或 getInstance(Locale 语言环境)
* getInstance(TimeZone, Locale)


（3）get（字段名）

例如：int year = get(Calendar.YEAR);



### 10.2.3 java.text.DateFormat 日期时间格式化

使用它的子类：SimpleDateFormat

y：年

M：月

d：日

D：一年中的第几天

H：24小时制的时

h：12小时制的时

m：分

s：秒

S：毫秒

E：星期

```java
SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

//把日期转字符串
String str = sf.format(Date的日期对象);
//把字符串解析为日期
Date d = sf.parse(字符串);
```



### 10.2.4 java.time包

#### 1、本地化日期/时间：LocalDate,LocalTime,LocalDateTime

now()：获取当前的日期或时间

of(x,x,x)：获取指定的日期或时间

withXxx(),  plusXxx(), minusXxx()：修改日期和时间，修改后要重新接收新对象

isLeapYear()：判断是否是闰年

...



#### 2、阶段日期或时间：间隔日期Period和持续时间Duration

between(x,y)：两个日期或时间



#### 3、格式化：DateTimeFormatter

使用预定义的模式：ISO_LOCAL_DATE

使用自定义模式：例如yyyy-MM-dd HH:mm:ss

使用FormatStyle枚举常量：LONG , MEDIUM, SHORT



## 10.3 系统相关类

### 1、java.lang.System类：系统工具类

static long currentTimeMillis()：获取系统时间的毫秒值

static void exit(x)：退出JVM

static void arraycopy(原数组， 原数组的起始下标， 目标数组， 目标数组的起始下标，一共复制几个元素)

static void gc()：通知垃圾回收器工作

static String getProperty(系统属性名)



### 2、java.lang.Runtime类：JVM运行环境

static Runtime getRuntime()

long totalMemory()

long freeMemory()

void gc()



## 10.4 数组相关的算法

### 10.4.1 反转

```java
//方式一：借一个数组
int[] arr = {1,2,3,4,5};

//(1)先创建一个新数组，长度和原来的数组一样
int newArr = new int[arr.length];
//(2)把原数组的元素，倒置放到新数组中
for(int i=0; i<arr.length; i++){
    newArr[i] = arr[arr.length-1-i];
}
//(3)指向新数组
arr = newArr;
```

```java
//方式二：首尾交换
int[] arr = {1,2,3,4,5};

int start = 0;
int end = arr.length;
//反转[start, end)
//交换次数：(end-start)/2
for(int i=0; i< (end-start)/2; i++){//循环次数代表交换的次数
    int temp = arr[start+i];
    arr[start+i] = arr[end-1-i];
    arr[end-1-i] = temp;
}
```

```java
//方式二：首尾交换
int[] arr = {1,2,3,4,5};

int start = 0;
int end = arr.length;
//反转[start, end)
for(int left=start, right=end-1; left<=right; left++,right--){//left代表左边元素的下标，right代表右边元素的下标
    int temp =  arr[left];
    arr[left] = arr[right];
    arr[right] = temp;
}
```

### 10.4.2 扩容

步骤：

（1）先创建一个新数组

* 可能在原数组基础上 + 一定长度
* 可能原数组长度翻倍

（2）把旧数组的数据赋值到新数组中

（3）放入新增元素

（4）指向新数组

```java
int[] arr = {1,2,3,4,5};

//（1）先创建一个新数组
int[] newArr = new int[arr.length+1];

//(2)复制元素
for(int i=0; i<arr.length; i++){//这里i<arr.length，比较越界
    newArr[i] = arr[i];
}

//(3)指向新数组
arr = newArr;

//(4)把新元素放入
arr[arr.length-1] = 新值;
```

### 10.4.3 插入

步骤：

（1）判断数组是否需要扩容

如果需要，先扩容

（2）把[index]位置和它后面的元素往右移动

（3）在[index]位置放入新元素

```java
int[] arr = {....};

//1、先扩容
//（1）先创建一个新数组
int[] newArr = new int[arr.length+1];

//(2)复制元素
for(int i=0; i<arr.length; i++){//这里i<arr.length，比较越界
    newArr[i] = arr[i];
}

//(3)指向新数组
arr = newArr;

//2、移动元素
System.arraycopy(arr, index, arr, index+1, 移动元素的个数);

//3、在[index]位置放入新元素
arr[index] = 新值;
```

### 10.4.4 删除

步骤：

（1）把[index+1]位置和它后面的元素往左移动

（3）把当前数组的最后一个元素还原

```java
int[] arr = {....};

//移动元素
System.arraycopy(arr, index+1, arr, index, 移动元素的个数);

arr[最后元素的下标] = 0;//引用数据类型的数组，就是为null
```

### 10.4.5 二分查找

```java
int[] arr = {....};//前提是有序的

int left = 0;
int right = arr.length-1;
int mid = (left + right)/2;
int index = -1;
int value = ?;

while(left<=right){
	if(arr[mid] == value){
        index = mid;
        break;
    }else if(arr[mid] > value){ //如果数组是从小到大，往左移动
        //修改右边界
        right = mid -1 ;
    }else{
        //修改左边界
        left = mid +1;
    }
    //因为left或right变了，mid也得重新计算
    mid = (left + right)/2;
}

if(index==-1){
    //没有
}
```



### 10.4.5 选择排序

```java
int[] arr = {....};

//轮数 = arr.length-1
for(int i=0; i<arr.length-1; i++){
    //(1)找出本轮最小值
    int minIndex = i;
    for(int j=i+1; j<arr.length-1; j++){
        if(arr[minIndex] > arr[j]){
            minIndex = j;
        }
    }
    
    //（2）如果本轮最小值不在它应该在的位置
    if(minIndex != i){
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
}
```

### 10.4.6 数组工具类java.util.Arrays

| 序号 | 方法签名                                                     | 方法功能简介                               |
| ---- | ------------------------------------------------------------ | ------------------------------------------ |
| 1    | static int binarySearch(数据类型[] a, 数据类型 key)          | 使用二分查找法在a数组中查找key的下标       |
| 2    | static 数据类型[] copyOf(数据类型[] original, int newLength) | 根据original复制一个新数组长度为newLength  |
| 3    | static 数据类型[] copyOfRange(数据类型[] original, int from, int to) | 根据original的[from,to)部分复制一个新数组  |
| 4    | static boolean equals(数据类型[] a1, 数据类型[] a2)          | 比较两个数组内容是否一致                   |
| 5    | static void fill(数据类型[] a, 数据类型val)                  | 用val的值填充a数组                         |
| 6    | static void sort(数据类型[] a)                               | 将a数组按照自然排序规则实现升序排列        |
| 7    | static void  sort(数据类型[] a, Comparator c)                | 将a数组按照c指定的定制比较规则实现升序排列 |
| 8    | static String toString(数据类型[] a)                         | 将数组的元素拼接为一个字符串返回           |

## 10.5 String类

### 10.5.1 String类的特点

1、String类是final修饰的，不能被继承

2、String类的底层使用数组存储

JDK1.9之前：char[] value

JDK1.9之后：byte[] value

3、String类的对象不可变

（1）字符串常量池中存储字符串常量，可以共享

（2）每次修改都会产生新对象，频繁修改的话效率不高

> 如果涉及到大量的字符串修改操作，建议使用StringBuffer或StringBuilder

如何实现不可变的？

（1）类本身不能继承，没有子类会重写

（2）底层存储的value数组都是final修饰

（3）底层存储的value数组私有化

（4）对外提供的所有修改字符串的方法，都返回一个新字符串对象

4、在Java程序代码中任意使用“”引起来的部分都是字符串的对象



### 10.5.2 String对象的创建

1、字面常量值

```java
String str = "hello";
```

2、使用构造器

```java
String str = new String();
String str = new String("hello");
char[] arr = {...};
String str = new String(arr);
byte[] arr = {...};
String str = new String(arr);
//....
```

3、静态方法

```
String str = String.copyValueOf(xx);
String str = String.valueOf(xx);
```

4、xx.toString()

```java
Student stu = new Student(xx);
String str = stu.toString();

StringBuffer s = new StringBuffer(xx);
String str = s.toString();
```



5、和字符串的拼接+

```
int a = 10;
String str = a + "";
```



### 10.5.3 String对象的个数

```java
String str = "hello";//1个
```

```java
String str = new String("atguigu");//2个
```

```java
String s1 = "hello";//1个
String s2 = "world";//1个
String s3 = s1 + s2 + "java";//"java"1个，s1 + s2拼接结果1个，最后结果1个
```



### 10.5.4 String对象的拼接

1、+

（1）常量池中的字符串常量 + 常量池中的字符串常量 ：结果是在常量池中

（2）变量 + xx：结果都在堆

（3）指向堆中的字符串常量 + xx：结果都在堆

（4）xx拼接结果.intern()：结果都在常量池

2、concat：拼接的结果都是新的字符串，都在堆中



### 10.5.5 String对象的比较

1、==：比较地址

2、equals(xx)：比较字符串内容，严格区分大小写

3、equalsIgnoreCase(xx)：比较字符串内容，不区分大小写

4、compareTo(xx)：比较字符串的大小，按照字符编码值比较，严格区分大小写

5、compareToIgnoreCase(xx)：比较字符串的大小，按照字符编码值比较，不区分大小写

6、java.text.Collator：文本校对器比较大小，按照指定语言环境的自然语言顺序比较大小（字典排序）

### 10.5.6 空字符串与空字符串的判断

```java
if(str !=null && str.isEmpty())
if(str !=null && str.length()==0)
if(str !=null && str.equals(""))
if("".equals(str))
```



### 10.5.7 String类的常用API

| 序号 | 方法签名                                                     | 方法功能简介                                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | String()                                                     | 创建空字符串                                                 |
| 2    | String(String original)                                      | 根据original创建一个新字符串                                 |
| 3    | static String valueOf(xx  value)                             | 根据value内容创建一个字符串                                  |
| 4    | String intern()                                              | 将字符串的内容存入常量池                                     |
| 5    | String concat()                                              | 字符串拼接                                                   |
| 6    | boolean equals(Object obj)                                   | 判断当前字符串与指定字符串内容是否已在，严格区分大小写       |
| 7    | boolean equalsIgnoreCase(String obj)                         | 判断当前字符串与指定字符串内容是否已在，不区分大小写         |
| 8    | int compareTo(String str)                                    | 比较当前字符串与指定字符串的大小，严格区分大小写             |
| 9    | int compareToIgnoreCase(String str)                          | 比较当前字符串与指定字符串的大小，不区分大小写               |
| 10   | boolean isEmpty()                                            | 判断当前字符串是否为空                                       |
| 11   | int length()                                                 | 返回当前字符串的长度                                         |
| 12   | String toLowerCase()                                         | 将当前字符串转为小写                                         |
| 13   | String toUpperCase()                                         | 将当前字符串转为大写                                         |
| 14   | String trim()                                                | 去掉当前字符串前后空白符                                     |
| 15   | boolean contains(xx)                                         | 判断当前字符串中是否包含xx                                   |
| 16   | int indexOf(xx)                                              | 在当前字符串中查找xx第一次出现的下标                         |
| 17   | int lastIndexOf(xx)                                          | 在当前字符串中查找xx最后一次出现的下标                       |
| 18   | String substring(int beginIndex)                             | 从当前字符串的[beginIndex, 最后]截取一个子串                 |
| 19   | String substring(int beginIndex, int endIndex)               | 从当前字符串的[beginIndex, endIndex)截取一个子串             |
| 20   | char charAt(index)                                           | 返回当前字符串[index]位置字符                                |
| 21   | char[] toCharArray()                                         | 将当前字符串的内容用一个字符数组返回                         |
| 22   | String(char[] value)                                         | 用value字符数组的元素构建一个新字符串                        |
| 23   | String(char[] value,int offset, int count)                   | 用value字符数组的[offset]开始的count个字符构建一个新字符串   |
| 24   | static String copyValueOf(char[] data)                       | 用data字符数组的元素构建一个新字符串                         |
| 25   | static String copyValueOf(char[] data, int offset, int count) | 用data字符数组的[offset]开始的count个字符构建一个新字符串    |
| 26   | static String valueOf(char[] data)                           | 用data字符数组的元素构建一个新字符串                         |
| 27   | static String valueOf(char[] data, int offset, int count)    | 用data字符数组的[offset]开始的count个字符构建一个新字符串    |
| 28   | byte[] getBytes()                                            | 将当前字符串按照平台默认字符编码方式编码为字节序列           |
| 29   | byte[] getBytes(字符编码方式)                                | 将当前字符串按照指定字符编码方式编码为字节序列               |
| 30   | String(byte[] bytes)                                         | 将bytes字节序列按照平台默认字符编码方式解码为字符串          |
| 31   | String(byte[] bytes,String charsetName)                      | 将bytes字节序列按照指定字符编码方式解码为字符串              |
| 32   | boolean startsWith(xx)                                       | 判断当前字符串是否以xx开头                                   |
| 33   | boolean endsWith(xx)                                         | 判断当前字符串是否以xx结尾                                   |
| 34   | boolean matchs(xx)                                           | 判断当前字符串是否满足xx正则                                 |
| 35   | String replace(xx,yy)                                        | 将当前字符串中所有xx替换为yy                                 |
| 36   | String replaceFirst(xx，value)                               | 将当前字符串中第一个满足xx正则的字符替换为value              |
| 37   | String repalceAll(xx， value)                                | 将当前字符串中所有满足xx正则的字符替换为value                |
| 38   | String[] split(xx)                                           | 将当前字符串按照xx正则拆分为多个字符串                       |
| 39   | void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) | 将当前字符串的[srtBegin,srcEnd)部分字符复制到dst字符数组中，dst数组从[dstBegin]开始存储 |

## 10.7 StringBuffer和StringBuilder

### 10.7.1 String类与StringBuffer和StringBuilder区别

String类的对象是不可变字符序列，StringBuffer和StringBuilder的对象是可变字符序列。

StringBuffer：老点，线程安全的，因为它的方法有synchronized修饰

StringBuilder：JDK1.5之后引入的，线程不安全，单线程情况下推荐使用。

### 10.7.2 StringBuffer和StringBuilder的API

| 序号 | 方法签名                                                     | 方法区功能简介                                               |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | StringBuffer()                                               | 创建一个空的可变字符序列，默认长度16                         |
| 2    | StringBuffer(String str)                                     | 用字符串str内容创建一个可变字符序列                          |
| 3    | StringBuffer append(数据类型 b)                              | 在当前字符序列后面追加b                                      |
| 4    | StringBufferinsert(int index, 数据类型 s)                    | 在当前字符序列[index]插入s                                   |
| 5    | StringBuffer delete(int start, int end)                      | 删除当前字符序列[start,end)部分字符                          |
| 6    | StringBuffer deleteCharAt(int index)                         | 删除当前字符序列[index]位置字符                              |
| 7    | void setLength(int newLength)                                | 修改当前字符序列的长度为newLength                            |
| 8    | void setCharAt(int index, char ch)                           | 替换当前字符序列[index]位置字符为ch                          |
| 9    | StringBuffer reverse()                                       | 将当前字符序列内容反转                                       |
| 10   | StringBuffer replace(int start, int end, String str)         | 替换当前字符序列[start,end)部分字符为str                     |
| 11   | int indexOf(String str)                                      | 在当前字符序列中开始查找str第一次出现的下标                  |
| 12   | int indexOf(String str, int fromIndex)                       | 在当前字符序列[fromIndex]开始查找str第一次出现的下标         |
| 13   | int lastIndexOf(String str)                                  | 在当前字符序列中开始查找str最后一次出现的下标                |
| 14   | int lastIndexOf(String str, int fromIndex)                   | 在当前字符序列[fromIndex]开始查找str最后一次出现的下标       |
| 15   | String substring(int start)                                  | 截取当前字符序列[start,最后]部分构成一个字符串               |
| 16   | String substring(int start, int end)                         | 截取当前字符序列[start,end)部分构成一个字符串                |
| 17   | String toString()                                            | 将当前可变字符序列的内容用String字符串形式表示               |
| 18   | void trimToSize()                                            | 如果缓冲区大于保存当前字符序列所需的存储空间，则将重新调整其大小，以便更好地利用存储空间。 |
| 19   | int length()                                                 | 返回当前字符序列的长度                                       |
| 20   | char charAt(int index)                                       | 返回当前字符序列[index]位置字符                              |
| 21   | void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) | 将当前字符串的[srtBegin,srcEnd)部分字符复制到dst字符数组中，dst数组从[dstBegin]开始存储 |

# 第十一章  泛型

## 11.1 泛型

泛型：参数化的类型，即把数据类型当做参数来传递	

​			又有的地方又称为泛化的类型，用一个单个大写字母，例如<T>来代表任意类型，这个T就是泛化的类型。



泛型的好处：

（1）表示某个变量的类型更灵活

（2）安全：有了泛型，在编译期间就可以避免不符合类型的数据赋值

（3）避免数据类型转换



## 11.2  泛型类或泛型接口

1、语法格式

```java
【修饰符】 class 类名<类型变量列表/泛型类型形参列表>{

}
【修饰符】 interface 接口名<类型变量列表/泛型类型形参列表>{

}
```

2、注意

（1）<类型变量列表/泛型类型形参列表>：使用单个的大写字母表示，例如：<T>，<E>,<R>...

（2）<类型变量列表/泛型类型形参列表>：可以多个，每个之间使用,分割，例如：<K,V>

（3）如果要指定<类型变量列表/泛型类型形参列表>的实际类型，必须是引用数据类型，不能是基本数据类型

（4）<类型变量列表/泛型类型形参列表>可能有上限，上限的要求：

< T  extends 上限1 & 上限2 ...>

上限中类只能有一个，如果有必须在最左边，接口的话可以多个。

多个上限之间是&(与)的关系。



3、什么时候才能确定<类型变量列表/泛型类型形参列表>的实际类型

（1）创建对象时

```java
Collection<String> c = new ArrayList<String>();
```

（2）继承

```java
class Student<T>{
	//....
}
class ChineseStudent extends Student<String>{

}
```

（3）实现接口

```java
class Circle implements Comparable<Circle>{
	public int compareTo(Circle c){
		//...
	}
}
```

4、泛型的擦除

如果在使用泛型类或泛型接口时，没有指定它的具体类型，那么泛型被擦除，泛型的类型就会自动按照它的第一个上限处理，如果没有指定上限，默认就是Object类型

```java
class Student<T>{
	//....
}

Student stu = new Student();//这里T按照Object
```

```java
class Student<T extends Number & Comparable & ....>{
	//....
}

Student stu = new Student();//这里T按照Number
```

## 11.3 泛型方法

1、语法格式

```java
【修饰符】 <类型变量列表/泛型类型形参列表> 返回值类型  方法名(【数据形参列表】)【throws 异常列表】
```

2、注意

（1）<类型变量列表/泛型类型形参列表>：使用单个的大写字母表示，例如：<T>，<E>,<R>...

（2）<类型变量列表/泛型类型形参列表>：可以多个，每个之间使用,分割，例如：<K,V>

（3）如果要指定<类型变量列表/泛型类型形参列表>的实际类型，必须是引用数据类型，不能是基本数据类型

（4）<类型变量列表/泛型类型形参列表>可能有上限，上限的要求：

< T  extends 上限1 & 上限2 ...>

上限中类只能有一个，如果有必须在最左边，接口的话可以多个。

多个上限之间是&(与)的关系。

（5）每一个泛型方法的<类型变量列表/泛型类型形参列表>是独立的，和别的方法无关，和类上面的泛型也无关。



3、什么时候确定泛型方法的<类型变量列表/泛型类型形参列表>具体类型？

方法被调用，根据方法的实参的类型自动推断。

## 11.4 泛型通配符

当我们在“使用”泛型类或泛型接口时，无法确定泛型的具体类型，可以使用通配符。

形式：

（1）泛型类/接口名<?>：?代表任意引用数据类型

（2）泛型类/接口名<?  extends 上限>：?代表的是该上限或上限的子类类型

（3）泛型类/接口名<?  super 下限>：?代表的是该下限或下限的父类类型



一些操作限制：

```java
	@Test
	public void test2() {
		Collection<?> c = new ArrayList();
		//<?>代表任意类型，不确定是什么类型
//		c.add("hello");
//		c.add(12);
		//类型不确定的意思，你添加什么，编译器就认为有风险，不让你添加
		
		Collection<? extends Number> c2 = new ArrayList();
		//<? extends Number>代表的是Number或Number的子类，不确定是哪种子类
		//可能是Integer，可能是Double....
//		c2.add(12);
//		c2.add(1.2);
		//类型不确定的意思，你添加什么，编译器就认为有风险，不让你添加
		
		Collection<? super Number> c3 = new ArrayList();
		//<? super Number>代表Number或Number的父类
		c3.add(12);
		c3.add(1.2);
//		c3.add("hello");
		//12和1.2对于Number或Number的父类来说都是安全的。
		//"hello"和Number系列没有继承关系。
	}
```



## 11.5 泛型的其他小问题

1、<>在左右两边 类型必须一致

```java
@Test
	public void test3() {
		//(1)两个<>中的类型一致  （对）
		Collection<String> c1 = new ArrayList<String>();
		
		//(2)两个<>中的类型不一致  （错）
//		Collection<Object> c2 = new ArrayList<String>();
		//因为Object是String的父类
		//Collection是ArrayList的父接口
//		但是Collection<Object>不是ArrayList<String>的父类
	}
```

2、JDK1.7之后允许右边<>里面空着，根据左边的自动推断

```java
@Test
	public void test4() {
		//JDK1.7之后，允许右边<>里面是空的
		Collection<String> c1 = new ArrayList<String>();//手动指定
		Collection<String> c2 = new ArrayList<>();//编译器认为是自动按照左边的处理
//		Collection<String> c3 = new ArrayList();//编译器认为它没有指定泛型，编译有警告
	}
```

3、try...catch的catch里面不能使用T这种来代表任意异常类型。

```java
@Test
	public void test5() {
		try {
			
		}catch(T t) {
			
		}
	}
```

4、泛型类不能创建数组对象

```java
@Test
	public void test6() {
		T[] arr;
		//T[]是一种数组类型，它是要在运行时，由编译器根据T的实际类型，动态编译出一种新的数据类型
//		arr = new T[5];//因为T编译期间不确定，那么编译器找对应的构造器是找不到
	}
```



# 第十二章 集合

## 12.1 集合的概念

集合：

​	是一种容器，用来装对象的容器，不能装基本数据类型。

​	数组也是容器，可以用来装基本数据类型，也可以用来装对象。

​	本质上，集合需要用对应的数据结构来实现。



集合分为两大类：

（1）Collection系列：存储一组对象，每个对象之间是独立的

（2）Map系列：存储一组映射关系(key,value)，即存储对值。



## 12.2 Collection系列

### 12.2.1 java.util.Collection接口

Collection接口：是Collection系列的集合的根接口，它没有提供任何的直接的实现，而是提供更具体的子接口（例如：List，Set，Queue等）的实现。有一些是可重复的，有一些时不可重复的，有一些时有序的，有一些是无序的。



### 12.2.2 Collection接口API

| 序号 | 归类 | 方法签名                          | 方法描述                                                     |
| ---- | ---- | --------------------------------- | ------------------------------------------------------------ |
| 1    | 添加 | add(E e)                          | 添加一个元素                                                 |
| 2    | 添加 | addAll(Collection c)              | 添加多个元素，把c集合的所有元素都添加到当前集合中，this = this ∪ c； |
| 3    | 删除 | clear()                           | 清空集合                                                     |
| 4    | 删除 | remove(Object obj)                | 删除一个元素，根据元素的equals()来判断是否是要被删除的元素，如果元素的类型没有重写equals方法，那么等价于==，如果重写了equals，那么就按照equals的规则来比较，一般比较内容。 |
| 5    | 删除 | removeAll(Collection c)           | 删除多个元素，把当前集合中和c共同的元素删除，即this  = this - this ∩ c; |
| 6    | 删除 | retainAll(Collection c)           | 删除多个元素，在当前集合中保留和c的共同的元素，即this = this ∩ c； |
| 7    | 查   | int size()                        | 获取元素的个数                                               |
| 8    | 查   | boolean contains(Object obj)      | 是否包含某个元素。根据元素的equals()来判断是否是要被删除的元素，如果元素的类型没有重写equals方法，那么等价于==，如果重写了equals，那么就按照equals的规则来比较，一般比较内容。 |
| 9    | 查   | boolean containsAll(Collection c) | 是否包含多个元素。判断当前集合中是否包含c集合的所有元素，即c是否是this的子集。 |
| 10   | 查   | boolean isEmpty()                 | 集合是否为空                                                 |
| 11   | 遍历 | Object[] toArray()                | 将集合中的元素用数组返回                                     |
| 12   | 遍历 | Iterator iterator()               | 返回一个迭代器对象，专门用于遍历集合                         |



### 12.2.3 Collection系列的集合遍历

#### 1、使用数组

```java
	@Test
	public void test01() {
		Collection<String> coll = new ArrayList<String>();
		coll.add("hello");
		coll.add("world");
		coll.add("java");
		
		Object[] array = coll.toArray();
		for (int i = 0; i < array.length; i++) {
			System.out.println(array[i]);
		}
	}
```

#### 2、使用foreach

```java
foreach的语法格式
for(元素的类型  元素名 :  容器名){

}

容器名：数组名，或者Collection系列的集合名称， 或者说实现了Iterable接口的其他容器名
```

```java
	@Test
	public void test02() {
		Collection<String> coll = new ArrayList<String>();
		coll.add("hello");
		coll.add("world");
		coll.add("java");
		
		for (String str : coll) {
			System.out.println(str);
		}
	}
```

```java
	@Test
	public void test03() {
		String[] coll = {"hello","world","java"};
		
		for (String str : coll) {
			System.out.println(str);
		}
	}
```

#### 3、使用迭代器

java.util.Iterator类型，接口类型。

（1）boolean hasNext()：判断当前游标后面是否还有下一个元素

（2）E next()：取出下一个元素

（3）remove()：删除刚刚迭代/取过的那个元素

```java
	@Test
	public void test04() {
		Collection<String> coll = new ArrayList<String>();
		coll.add("hello");
		coll.add("world");
		coll.add("java");
		
		Iterator<String> iterator = coll.iterator();
		while(iterator.hasNext()) {
			String next = iterator.next();
			System.out.println(next);
		}
	}
```

### 12.2.4 删除Collection元素

#### 1、明确删除

```java
	@Test
	public void test07() {
		Collection<String> coll = new ArrayList<String>();
		coll.add("hello");
		coll.add("world");
		coll.add("java");
		
		coll.remove(new String("hello"));//可以
		coll.remove("hello");//可以，因为是根据元素的equals方法，String重写了equals
		
		for (String str : coll) {
			System.out.println(str);
		}
	}
```

#### 2、根据条件删除

```java
@Test
	public void test08() {
		Collection<String> coll = new ArrayList<String>();
		coll.add("hello");
		coll.add("world");
		coll.add("java");
		
		Iterator<String> iterator = coll.iterator();
		while(iterator.hasNext()) {
			String next = iterator.next();
			if(next.length()<=4) {
				iterator.remove();
			}
		}
		
		for (String string : coll) {
			System.out.println(string);
		}
	}
```

#### 3、以下两种错误不能犯

```
	@Test
	public void test09() {
		Collection<String> coll = new ArrayList<String>();
		coll.add("hello");
		coll.add("world");
		coll.add("java");
		
		Iterator<String> iterator = coll.iterator();
		while(iterator.hasNext()) {
			String next = iterator.next();
			if(next.length()<=4) {
				coll.remove(next);//错误
			}
		}
		
		for (String string : coll) {
			System.out.println(string);
		}
	}
```

```java
	@Test
	public void test10() {
		Collection<String> coll = new ArrayList<String>();
		coll.add("hello");
		coll.add("world");
		coll.add("java");
		
		for (String string : coll) {
			if(string.length()<=4) {
				coll.remove(string);//错误的
			}
		}
	}
```

### 12.2.5 java.util.Iterator和java.lang.Iterable

java.lang.Iterable：表示可迭代的，它的抽象方法：Iterator iterator()，实现这个接口意味着可以使用foreach遍历。Java集合框架中Collection系列的集合都实现了这个接口，意味着可以使用foreach循环。而Map系列集合没有实现这个接口，不能直接使用foreach，需要通过entrySet(), keySet(), values()进行转换，然后再使用foreach。



java.util.Iterator：表示迭代器。每一种实现了Iterable接口的集合内部，都会有一个内部类，例如：ArrayList的内部有一个Itr内部类，实现Iterator接口，用于集合的迭代。



java.util.Iterator的抽象方法：

（1）boolean hasNext()

（2）E next()

（3）void remove()



java.util.Iterator的子接口：java.util.ListIterator。List系列的集合内部有提供listIterator()方法可以获取ListIterator对象，在List系列的集合内部有内部类实现了ListIterator接口。它的抽象方法：

（1）boolean hasNext()

（2）E next()

（3）void remove()

（4）boolean hasPrevious()

（5）E previous()

（6）void add(E e)

（7）void set(E e)

（8）int nextIndex()

（9）int previousIndex()

```java
	@Test
	public void test14() {
		List<String> list = new ArrayList<>();
		list.add("hello");
		list.add("world");
		list.add("java");
		list.add("chai");
		
//		ListIterator<String> listIterator = list.listIterator();//默认游标仍然在最开始
		ListIterator<String> listIterator = list.listIterator(list.size());//游标指向最后
		while(listIterator.hasPrevious()) {
			String str = listIterator.previous();
			System.out.println(str);
		}
	}
```



## 12.3 List系列

### 12.3.1 List系列的集合特点

（1）有序，可以通过索引/下标进行操作

（2）可重复的：调用equals相同的元素



### 12.3.2 List集合的API

在Collection接口的API基础之上**增加**如下方法：

1、添加

add(int index, E e)：在[index]位置添加一个

addAll(int index , Collection c)：在[index]位置添加多个

2、删除

E remove(int index)：删除[index]位置的元素，返回被删除的元素

3、修改

E set(int index, E e)：替换[index]位置的元素，返回被替换的元素

4、查询

E get(int index)：返回[index]位置的元素

List<E> subList(int start, int end)：截取[start,end)部分的元素

int indexOf(Object obj)：返回obj在当前集合中第一次出现的下标

int lastIndexOf(Object obj)：返回obj在当前集合中最后一次出现的下标

5、遍历

在原来Iterator和foreach遍历的基础上增加了：

ListIterator listIterator()：默认游标在[0]开始

ListIterator listIterator(int index)：默认游标在[index]位置



### 12.3.3 List接口的常用实现类

#### 1、ArrayList：动态数组

#### 2、Vector：动态数组

#### 3、LinkedList：双向链表

#### 4、Stack：栈



面试题：ArrayList与Vector的区别

ArrayList：新一点， 线程不安全，扩容的机制默认为原来的1.5倍

Vector：最古老的动态数组，线程安全的，扩容的机制默认为原来的2倍，还多支持了一个旧版的迭代器Enumeration迭代。

## 12.4 Set系列

### 12.4.1 Set系列的集合的特点

（1）不可重复

（2）TreeSet：按大小顺序，LinkedHashSet：按照添加的顺序，HashSet：无序



### 12.4.2 Set接口的实现类们

HashSet/LinkedHashSet：

​	如何区别元素的不可重复。依赖于元素的hashCode和equals方法

TreeSet：

​	如何区别元素的不可重复以及如何保证元素的大小顺序？

​	要么元素实现java.lang.Comparable接口，重写int compareTo(T t)方法，

​	要么指定java.util.Comparator接口的实现类对象，重写int compare(T t1, T t2)方法

​	如果希望保持一致性，在重写compareTo时，一般也会重写equals方法。不是语法要求，而且逻辑意义问题。